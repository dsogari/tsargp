---
title: Parser - Library - Docs
---

import { Callout } from 'nextra/components';

# Parser

The `ArgumentParser` class is the centerpiece of the library. It can be instantiated with a set of
option _definitions_ and provides methods to parse command-line arguments into option values.

## Option values

The result of argument parsing is an object that contains the option values corresponding to the
option definitions given in the parser constructor. There are two main ways to get the values, as
explained below.

### Using a newly-created object

This is the easiest, most common method: you just call `parse` and use its result. This method
accepts two optional parameters:

- `command` - the raw command line (`string{:ts}`) or the command-line arguments (`string[]{:ts}`)
- `config` - the [parse configuration](#parse-configuration)

Normally you should _not_ need to pass these parameters, as they have sensible default values:

- `command` - `process.env['COMP_LINE']{:ts}` or `process.argv.slice(2){:ts}`
- `config.termWidth` - `process.stdout.columns{:ts}` or `process.stderr.columns{:ts}`
- `config.compIndex` - `Number(process.env['COMP_POINT']){:ts}` or `undefined{:ts}`

If you feel the need to configure the parser, make sure to first understand how
[bash completion](#bash-completion) works.

When declaring async [executing callbacks](#executing-callbacks) in the option definitions, you
should call the `parseAsync` method instead, which returns a promise that can be awaited in order
resolve those callbacks.

### Using your own class

This is a more flexible method that allows you to pass an existing object or class instance, which
will be filled with the parsed option values. The method is named `parseInto` and accepts the same
parameters as above, except for an additional (first) parameter:

- `values` - the options' values to parse into

When using TypeScript, this parameter will be type-checked at compile-time against the expected type
of the option values for a given set of option definitions. You may want to use IntelliSense to peak
at the resulting type of the `parse` method (or declare a temporary type alias for
`OptionValues<typeof _your_options_>{:ts}`) to see how the object is structured.

This method returns a promise that can be awaited in order to resolve async
[executing callbacks](#executing-callbacks).

## Option validation

The term _validation_ here means verifying the sanity of an option's definition. It is intended for
development and testing, _not_ for use in production where it would impose an unwanted performance
penalty on your application. The validations behave like assertions: they assert that your options
will work as expected when delivered to end users.

To validate a set of option definitions, you must call the `validate` method on the parser instance.
The following sections describe the various kinds of validation performed by this method. In most of
them, the option key specified in the option definitions object is included in the error message.

### Names validation

Option names are subject to some restrictions, and any option definition that does not satisfy one
of them will trigger an error. They are listed below.

#### No option name

An option should have at least one _non-empty_ name.

#### Invalid option name

An option name must not contain whitespace or the equals sign `'='{:ts}`, since this character may
be used as option-value separator on the command-line. Any other character (including Unicode code
points) is allowed. Empty strings and `null{:ts}`s are ignored. A flag option's
[negation names](options.mdx#negation-names) and the
[positional marker](options.mdx#positional--marker) are included in the validation.

#### Duplicate option name

An option should not have duplicate names, and there cannot be two options with the same name. Empty
strings and `null{:ts}`s are ignored. A flag option's [negation names](options.mdx#negation-names)
and the [positional marker](options.mdx#positional--marker) are included in the validation.

### Enums validation

Enumerated values are subject to some restrictions, and any option definition that does not satisfy
one of them will trigger an error. They are listed below.

#### Zero enum values

There may not be an option with zero enumerated values. The enumeration array should have _non-zero_
length.

#### Duplicate enum value

There may not be an option with duplicate enumerated values. The enumeration array _should not_
contain duplicate elements.

### Value validation

Non-niladic options may define a default value and an example value. If present, these attributes
are subject to the same set of constraints as that of the command-line arguments, and any option
definition whose values do not satisfy one of them will trigger an error. They are listed below.

<Callout type="info">
  This does not apply to [default callbacks](options.mdx#default-value--callback) (they are ignored
  during validation).
</Callout>

#### Enums constraint violation

If the [enums](options.mdx#enumeration) attribute is present, then default and example values must
equal one of the enumerated values after being normalized. (The enumerated values themselves are not
normalized.)

#### Regex constraint violation

In a string-valued option, if the [regex](options.mdx#regular-expression) attribute is present, then
default and example values must match the regular expression after being normalized.

#### Range constraint violation

In a number-valued option, if the [range](options.mdx#numeric-range) attribute is present, then
default and example values must be within this range after being normalized.

#### Limit constraint violation

In an array-valued option, if the [limit](options.mdx#count-limit) attribute is present, then
default and example values must have a length that does not exceed the given limit after being
normalized.

### Requirements validation

When an option declares that it requires other options, these requirements are subject to some
restrictions, and any option definition that does not satisfy one of them will trigger an error.
They are listed below.

#### Option requiring itself

An option must _not_ declare a requirement/expression that includes its own option key.

#### Unknown required option

An option must _not_ declare a requirement/expression that includes an unknown option key.

#### Niladic option required with a value

An option must _not_ declare a requirement/expression that includes an option key referencing a
niladic option, _if_ it includes a required value that is neither `undefined{:ts}` nor `null{:ts}`.

#### Incompatible required value data type

Since a requirement may be an object with values of any kind, the data type of these values must be
validated at run-time. An option must _not_ declare a requirement/expression that includes an option
key referencing a non-niladic option, _if_ it includes a required value that does not conform to the
data type expected by that option.

#### Constraint violation

If an option declares a requirement/expression that includes a required value, then that value is
subject to the same set of constraints as that of the command-line arguments, so it must satisfy the
restrictions listed in [value validation](#value-validation).

### Positional validation

Options declared with the [positional](options.mdx#positional--marker) attribute are subject to some
restrictions, and any option definition that does not satisfy one of them will trigger an error.
They are listed below.

#### Duplicate positional option

Since positional arguments are unnamed, they must pertain to exactly one option. Hence, there
_cannot_ be two options with the positional attribute in the same set of option definitions.

#### Empty positional marker

If an option is declared with a positional marker, this marker _cannot_ be the empty string.

### Version validation

A version option is very simple and has only one restraint: it must _not_ contain an empty version
string; otherwise it will trigger an error.

## Parse configuration

The parsing procedure can be configured with a `ParseConfig` object that has a few optional
properties, as described below.

### Terminal width

The `termWidth` property is the desired terminal width that is used to print the help message (in
number of columns). This value is passed directly to the constructor of the
[formatter](formatter.mdx) class, when processing a help option.

### Completion index

The `compIndex` property is the completion index of a raw command line. When supplying the parsing
methods with a command-line string, this value instructs the parser to perform bash completion when
parsing the argument that overlaps this position in the string.

## Asynchronous parsing

To understand how the parser supports asynchronous operations, we need to review the kinds of
callbacks that an option definition may declare. There are six of them:

- [default callback](options.mdx#default-value--callback)
- [parse callback](options.mdx#parse-callback)
- [parse delimited](options.mdx#parse-delimited)
- [resolve callback](options.mdx#resolve-callback)
- [execute callback](options.mdx#execute-callback)
- [complete callback](options.mdx#complete-callback)

They can be categorized as either "parsing" callbacks or "executing" callbacks, and are further
explained below.

### Parsing callbacks

The default, parse and parse delimited callbacks can return promises. They may even return different
data types from one invocation to the next (e.g., a promise and a non-promise). To support these use
cases, the library checks the return type of each invocation to know if it is a promise or not, and
act accordingly.

In the case of the default callback, since there is no previous value to worry about, its handling
of promises is very simple: if the returned value is a promise, then it is chained with a callback
that normalizes the value, and the new promise becomes the option value; otherwise, the returned
value is normalized and set as the option value. This will also be the case of single-valued option
types, since these options do not need the previous value: it simply gets replaced.

Array-valued options, on the other hand, suffer from the fact that the parser always appends the
values it parses. This happens because the parser does not know in advance how many parameters there
will be for an option (although it ensures that the option value is reset to an empty array when it
encounters the option name, if the [append](options.mdx#append-values) attribute is not set). In
this case, there are four possible combinations of previous value and callback invocation result:

1. non-promise and non-promise
2. non-promise and promise
3. promise and promise
4. promise and non-promise

They are handled in following manner:

- The first case is handled by simply appending the normalized elements to the previous value, since
  it is a synchronous operation.
- The second and third cases are handled by chaining the returned promise with an async callback
  that appends the normalized elements to the (awaited) previous value.
- The fourth case is handled by chaining the existing promise with a callback that appends the
  normalized elements to the previous value.

Note that, for array-valued options, once a promise is returned from a parsing callback there's no
turning back to a non-promise.

<Callout type="info">
  A special case occurs when a variadic array option is specified on the command-line without
  parameters. In that case, the parser must initialize the option value to an empty array. This
  means that, even if an option declares an async parsing callback in its definition, the parser
  might exit the loop before calling the callback, thus leaving the value as an empty array
  (non-promise). This is not a problem, since the `await` expression can be called on a non-promise.
</Callout>

None of these cases make it necessary to call `parseAsync` or await the return of `parseInto`, since
the callback promises are _inside_ the resulting object. But you must await each value in this
object that is a promise, in order to obtain the value.

### Executing callbacks

The resolve, execute and complete callbacks are the ones that may cause the parser to accumulate
promises that will be returned by the `parseAsync` or `parseInto` methods, which then need to be
awaited in order to await their resolution.

In the case of the resolve and complete callbacks, once awaited, the promise throws a string that
should be caught and printed on a terminal. They are the version or the completion words,
respectively.

In the case of the execute callback, once awaited, the result will be the option values.

## Bash completion

Quoting the [Bash docs]:

> When word completion is attempted for an argument to a command for which a completion
> specification (a compspec) has been defined using the `complete` builtin (see Programmable
> Completion Builtins), the programmable completion facilities are invoked.

The parser does not use the completion facilities, because it relies simply on the command line
string and the completion index into that string, which can be retrieved from the following
environment variables (available when performing completion):

- `COMP_LINE` - the current command line
- `COMP_POINT` - the index of the current cursor position relative to the beginning of the current
  command

The way it does this is by inserting a placeholder into the command-line argument that is under the
completion index. This placeholder is then looked for at each iteration in the parsing loop to know
when to perform completion.

The result of completion is a list of words separated by line breaks, and should be printed on the
terminal so that the `complete` builtin can perform the final completion step.

### Completion algorithm

The completion algorithm implemented by the library is explained below. In what follows, _comp_ is
the word being completed, i.e., the command-line argument ending at the completion index (it may be
an empty string):

1. If _comp_ is expected to be an option name:
   - If _comp_ is a known option name, that name is returned; else
   - If there's no positional option, the available option names are filtered by the prefix _comp_,
     and then returned; else
   - _comp_ is treated as a parameter of the positional option; go to step 2
2. _comp_ is the parameter of a non-niladic option:
   - If the option has a [complete callback](options.mdx#complete-callback), it is called with
     _comp_ and its result is returned; else
   - If it is a boolean option, the words `'true'{:ts}` and `'false'{:ts}` are filtered by the prefix
     _comp_, and then returned; else
   - If the option has [enumerated values](options.mdx#enumeration), those values are converted to
     string, filtered by the prefix _comp_, and then returned; else
   - If it is a variadic array option, and the parameter was specified neither with a positional
     marker nor as an [inline value](#inline-values), the available option names are filtered by the
     prefix _comp_ and returned; else
   - No words are returned, and the default bash completion (if enabled with `-o`) is attempted.

During completion, help and version options are skipped, while others are processed as usual. This
means that a completion callback can inspect the values parsed before it, in order to make better
suggestions based on those values.

## Miscellaneous

### Name suggestions

During parsing, there are two situations in which the parser might suggest option names:

- when it expects an option name and the current argument is not a valid name (and there is no
  positional option)
- when it expects an option parameter and the current argument fails to be parsed, and the affected
  option is a variadic array option (but only if the argument was specified neither with a
  positional marker nor as an [inline value](#inline-values))

In these cases, the parser selects option names that are similar to the current argument using the
[Gestalt algorithm], and includes them in the error message.

### Error styles

The validation and parsing methods may throw errors, and the error messages can be styled. Styles
can be configured with an additional parameter to the parser constructor, which contains the
following optional properties:

- `boolean` - the style of boolean values (defaults to `fg.yellow`)
- `string` - the style of string values (defaults to `fg.green`)
- `number` - the style of number values (defaults to `fg.yellow`)
- `regex` - the style of regular expressions (defaults to `fg.red`)
- `option` - the style of option names (defaults to `fg.magenta`)
- `url` - the style of URLs (defaults to `fg.brightBlack`)
- `text` - The style of general text (defaults to `tf.clear`)

These styles are _not_ used in the help option's [format](options.mdx#format--heading-style)
attribute. They may have the same values, but you should configure both if you want to customize
both error messages and help messages.

### Inline values

Option parameters may be passed on the command-line using the syntax `<name>=<value>`. This syntax
is only valid for non-niladic options and cannot be used with the positional marker.

[Bash docs]: https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html
[Gestalt algorithm]: https://www.wikiwand.com/en/Gestalt_pattern_matching
