---
title: Parser - Library - Docs
---

import { Callout } from 'nextra/components';

# Parser

The `ArgumentParser` class is the main library component. It can be instantiated with a set of
option _definitions_ and provides methods to parse command-line arguments into option values.

## Option values

The result of argument parsing is an object that contains the option values corresponding to the
option definitions given in the parser constructor. There are two main ways to get the values, as
explained below.

### Using a newly-created object

This is the easiest, most common method: you just call `parse` and use its result. This method
accepts two optional parameters:

- `command` - the raw command line (`string{:ts}`) or the command-line arguments (`string[]{:ts}`)
- `config` - the [parse configuration](#parse-configuration)

Normally you should _not_ need to pass these parameters, as they have sensible default values:

- `command` - `process.env['COMP_LINE']{:ts}` or `process.argv.slice(2){:ts}`
- `config.compIndex` - `Number(process.env['COMP_POINT']){:ts}` or `undefined{:ts}`

If you feel the need to configure the parser, make sure to first understand how
[bash completion](#bash-completion) works.

When declaring async [executing callbacks](#executing-callbacks) in the option definitions, you
should call the `parseAsync` method instead, which returns a promise that can be awaited in order
resolve those callbacks.

### Using your own class

This is a more flexible method that allows you to pass an existing object or class instance, which
will be filled with the parsed option values. The method is named `parseInto` and accepts the same
parameters as the previous one, except for an additional (first) parameter:

- `values` - the option values to parse into

When using TypeScript, this parameter will be type-checked at compile-time against the expected type
of the option values for a given set of option definitions. You may want to use IntelliSense to peak
at the resulting type of the `parse` method (or declare a temporary type alias for
`OptionValues<typeof _your_options_>{:ts}`) to see how the object is structured.

This method returns a promise that can be awaited in order to resolve async
[executing callbacks](#executing-callbacks).

## Parse configuration

The parsing procedure can be configured with a `ParseConfig` object that (currently) has only one
optional property, as described below.

### Completion index

The `compIndex` property is the completion index of a raw command line. When supplying the parsing
methods with a command-line string, this value instructs the parser to perform bash completion when
parsing the argument that overlaps this position in the string.

## Asynchronous parsing

To understand how the parser supports asynchronous operations, we need to review the kinds of
callbacks that an option definition may declare. There are seven of them:

- [default callback](options.mdx#default-value--callback)
- [parse callback](options.mdx#parse-callback)
- [parse delimited](options.mdx#parse-delimited)
- [complete callback](options.mdx#complete-callback)
- [resolve callback](options.mdx#resolve-callback)
- [execute callback](options.mdx#execute-callback)
- [command callback](options.mdx#command-callback)

They can be categorized as either _parsing_ callbacks or _executing_ callbacks, and are further
explained below.

### Parsing callbacks

The default, parse and parse delimited callbacks can return promises. They may even return different
data types from one invocation to the next (e.g., a promise and a non-promise). To support these use
cases, the library checks the return type of each invocation to know if it is a promise or not, and
act accordingly.

In the case of the default callback, since there is no previous value to worry about, handling
promises is very simple: if the returned value is a promise, then it is chained with a callback
that normalizes the value, and the new promise becomes the option value; otherwise, the returned
value is normalized and set as the option value. This will also be the case of single-valued option
types, since these options do not need the previous value: it simply gets replaced.

Array-valued options, on the other hand, suffer from the fact that the parser always appends the
values it parses. This happens because the parser does not know in advance how many parameters there
will be for an option (although it ensures that the option value is reset to an empty array when it
encounters the option name, if the [append](options.mdx#append-values) attribute is not set). In
this case, there are four possible combinations of previous value and callback invocation result:

1. non-promise and non-promise
2. non-promise and promise
3. promise and promise
4. promise and non-promise

They are handled in following manner:

- The first case is handled by simply appending the normalized elements to the previous value, since
  it is a synchronous operation.
- The second and third cases are handled by chaining the returned promise with an async callback
  that appends the normalized elements to the (awaited) previous value.
- The fourth case is handled by chaining the existing promise with a callback that appends the
  normalized elements to the previous value.

Note that, for array-valued options, once a promise is returned from a parsing callback there's no
turning back to a non-promise.

<Callout type="info">
  A special case occurs when a variadic array option is specified on the command-line without
  parameters. In that case, the parser must initialize the option value to an empty array. This
  means that, even if an option declares an async parsing callback in its definition, the parser
  might exit the loop before calling the callback, thus leaving the value as an empty array
  (non-promise). This is not a problem, since the `await` expression can be called on a non-promise.
</Callout>

None of these cases make it necessary to call `parseAsync` or await the return of `parseInto`, since
the callback promises are _inside_ the resulting object. But you must await each value in this
object that is a promise, in order to obtain the value.

### Executing callbacks

The complete, resolve, execute and command callbacks are the ones that may cause the parser to
accumulate promises that will be returned by the `parseAsync` or `parseInto` methods, which then
need to be awaited in order to await their resolution.

In the case of the complete and resolve callbacks, once awaited, the promise throws a string that
should be caught and printed on a terminal. They are the version or the completion words,
respectively.

In the case of the execute and command callbacks, once awaited, the result will be the option
values.

## Bash completion

Quoting the [Bash docs]:

> When word completion is attempted for an argument to a command for which a completion
> specification (a compspec) has been defined using the `complete` builtin (see Programmable
> Completion Builtins), the programmable completion facilities are invoked.

The parser does not use the completion facilities, because it relies on the command line string and
the completion index into that string, which can be retrieved from the following environment
variables (available when performing completion):

- `COMP_LINE` - the current command line
- `COMP_POINT` - the index of the current cursor position relative to the beginning of the current
  command

The way it does this is by inserting a placeholder into the command-line argument that is under the
completion index. This placeholder is then looked for at each iteration in the parsing loop to know
when to perform completion.

The result of completion is a list of words separated by line breaks, and should be printed on the
terminal so that the `complete` builtin can perform the final completion step.

### Completion algorithm

The completion algorithm implemented by the library is explained below. In what follows, _comp_ is
the word being completed, i.e., the command-line argument ending at the completion index (it may be
an empty string):

1. If _comp_ is expected to be an option name:
   - If _comp_ is a known option name, that name is returned; else
   - If there's no positional option, the available option names are filtered by the prefix _comp_,
     and then returned; else
   - _comp_ is treated as a parameter of the positional option; go to step 2
2. _comp_ is the parameter of a non-niladic option:
   - If the option has a [complete callback](options.mdx#complete-callback), it is called with
     _comp_ and its result is returned; else
   - If it is a boolean option, the words `'true'{:ts}` and `'false'{:ts}` are filtered by the prefix
     _comp_, and then returned; else
   - If the option has [enumerated values](options.mdx#enumeration), those values are converted to
     string, filtered by the prefix _comp_, and then returned; else
   - If it is a variadic array option, and the parameter was specified neither with a positional
     marker nor as an [inline value](#inline-values), the available option names are filtered by the
     prefix _comp_ and returned; else
   - No words are returned, and the default bash completion (if enabled with `-o`) is attempted.

During completion, help and version options are skipped, while others are processed as usual. This
means that a completion callback can inspect the values parsed before it, in order to make better
suggestions based on those values.

## Miscellaneous

### Error messages

Error messages generated by the parsing procedure can be customized using the validator's
[error configuration](validator.mdx#error-configuration), which can be provided as an additional
parameter to the parser constructor.

### Name suggestions

During parsing, there are two situations in which the parser might suggest option names:

- when it expects an option name and the current argument is not a valid name (and there is no
  positional option)
- when it expects an option parameter and the current argument fails to be parsed, and the affected
  option is a variadic array option (but only if the argument was specified neither with a
  positional marker nor as an [inline value](#inline-values))

In these cases, the parser selects option names that are similar to the current argument using the
[Gestalt algorithm], and includes them in the error message.

### Inline values

Option parameters may be passed on the command-line using the syntax `<name>=<value>`. This syntax
is only valid for non-niladic options and cannot be used with the positional marker.

[Bash docs]: https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html
[Gestalt algorithm]: https://www.wikiwand.com/en/Gestalt_pattern_matching
