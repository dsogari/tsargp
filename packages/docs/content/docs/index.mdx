---
title: Introduction - Docs
---

import { FileTree, Tabs } from 'nextra/components';

# Introduction

**tsargp** is a command-line argument parsing library that helps you write clean code.

## Features

| Usability            | Functionality          | Presentation            |
| -------------------- | ---------------------- | ----------------------- |
| Zero-dependency      | Word completion        | Help message formatting |
| Fully declarative    | Option validation      | Text wrapping/alignment |
| Type-checked         | Option requirements    | Paragraphs and lists    |
| Browser-compatible   | Name suggestions       | [SGR] colors and styles |
| 30KB minified        | Nested commands        | Option grouping/hiding  |
| ESM-native           | Asynchronous callbacks | Help sections/usage     |
| Online documentation | GNU's _short-options_  |                         |

## Motivation

Why use this library when there are already many good argument parsers on npm?

Its most distinctive feature is a _declarative_ API. Very few libraries on npm that we know of (at
the time of writing) have this feature (worth mentioning [meow], [yargs] and [oclif]). Most others
have either imperative or fluent interface, whereas **tsargp** offers a way to declare all of your
command-line options in a single `object`.

Furthermore, by using TypeScript, it ensures that the values resulting from argument parsing have
_accurate_ data types, i.e., they reflect the attributes specified in the options' definitions. In
particular, an option's value will be a union literal if you declare a choice mapping in its
definition. Even JSDoc comments are preserved in IntelliSense!

## Installation

```sh copy
npm install tsargp
```

## Quick Start

Let's say your CLI name is `cli`. Then, your folder structure could look like this:

<FileTree>
  <FileTree.Folder name="lib" defaultOpen>
    <FileTree.File name="cli.ts" />
    <FileTree.File name="cli.options.ts" />
    <FileTree.File name="cli.options.spec.ts" />
  </FileTree.Folder>
</FileTree>

Define your command-line options:

```ts copy filename="cli.options.ts" /cli/
import { type Options, ... } from 'tsargp';

export default {
  // define the options' attributes...
} as const satisfies Options;
```

Import them in your main script:

```ts copy filename="cli.ts" {3}
#!/usr/bin/env node
import { ArgumentParser } from 'tsargp';
import options from './cli.options.js';

try {
  const parser = new ArgumentParser(options);
  const values = await parser.parse(); // use this to get the options' values
  // await parser.parseInto(myValues); // use this to fill an existing object or class instance
} catch (err) {
  if (err instanceof Error) {
    console.error(`${err}`); // genuine errors
    process.exitCode = 1;
  } else {
    console.log(`${err}`); // help message, version or completion words
  }
}
```

Validate them in your test script:

```ts copy filename="cli.options.spec.ts" {2}
import { OptionValidator } from 'tsargp';
import options from './cli.options.js';

describe('cli', () => {
  it('should have valid options', async () => {
    const validator = new OptionValidator(options);
    const { warning } = await validator.validate();
    expect(warning).toBeUndefined(); // or check warnings that are important to your application
  });
});
```

Optionally, enable word completion for your shell:

<Tabs items={['Bash', 'PowerShell', 'Zsh', 'Fish', 'Nushell']}>
  <Tabs.Tab>
    ```bash copy /cli/ /<path_to_main_script>/
    complete -o default -C <path_to_main_script> cli
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```ps copy /cli/ /<path_to_main_script>/
    Register-ArgumentCompleter -Native -CommandName cli -ScriptBlock {
      param($word, $cmdLine, $cursorPos)
        $env:BUFFER="$cmdLine"; $env:CURSOR=$cursorPos
        <path_to_main_script>
        $env:BUFFER=$null; $env:CURSOR=$null # reset variables
    }
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```zsh copy /cli/ /<path_to_main_script>/
    compdef 'export BUFFER CURSOR; _values cli `<path_to_main_script>`' cli
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```fish copy /cli/ /<path_to_main_script>/
    complete cli -f -a '(set -x BUFFER (commandline -c); <path_to_main_script>; set -e BUFFER)'
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```nu copy /cli/ /<path_to_main_script>/
    $env.config.completions.external.completer = {|spans|
      {
        cli: {
          with-env { BUFFER: ($spans | str join ' ') } { <path_to_main_script> } | lines
        }
      } | get $spans.0 | each { || do $in }
    }
    ```
  </Tabs.Tab>
</Tabs>

[SGR]: https://en.wikipedia.org/wiki/ANSI_escape_code#Select_Graphic_Rendition_parameters
[meow]: https://www.npmjs.com/package/meow
[yargs]: https://yargs.js.org/
[oclif]: https://oclif.io/
