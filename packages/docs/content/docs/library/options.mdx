---
title: Options - Library - Docs
---

import { Callout } from 'nextra/components';

# Options

A command line interface can be composed of subcommands and options (also known as _flags_). The options allow a calling application or user to configure the command that will run. **tsargp** offers a selection of option types that should suit most applications. In the next sections, we present the available types and describe them in detail.

## Option types

There are seven types of options, as summarized in the table below:

| Type | Parameters | Attribute classes |
| --- | --- | --- |
| [help] | niladic | [basic], [message] |
| [version] | niladic | [basic], [message] |
| [command] | niladic[^1] | [basic], [value], |
| [flag] | niladic | [basic], [value], [environment] |
| [single] | positional, inline, monadic | [basic], [value], [environment], [parameter], [selection] |
| [array] | positional, inline, variadic, delimited, appended | [basic], [value], [environment], [parameter], [selection] |
| [function] | positional, inline, configurable | [basic], [value], [environment], [parameter] |

The next sub-sections cover some concepts that may be used throughout this page.

### Option type

The `type` attribute of an option's definition indicates the type of the option. It is the _only_ required attribute of any option, and is used as a [discriminant] for determining the available attributes of a specific option.

### Option parameters

Each type of option expects different number of parameters on the command line:

- **niladic** - no parameter
- **monadic** - single parameter
- **variadic** - variable number of parameters
- **delimited** - values can be delimited with a [parameter separator]
- **appended** - can be specified multiple times and [append values]
- **configurable** - can be configured with a certain [parameter count]
- **inline** - allows parameters to be inlined with an option name

<Callout type="info">

When a single-valued option is specified multiple times on the command line, its value is replaced each time. This is also the default behavior of an array-valued option, unless [append values] is set.

</Callout>

### Option value

The data type of an option value in the [resulting object] depends on the option type. You can check the effective data type of the option values for a set of option definitions by inspecting the IntelliSense output of:

- the result of the parser's [`parse`] method
- the result of the `valuesFor` function
- a type alias for `OptionValues<typeof your_options>{:ts}`

<Callout type="info">

Except for help and version options, which do not have values, the initial value of any option is `undefined{:ts}`.

</Callout>

### Constraints

Non-niladic options can be configured with constraint attributes, which may be of two kinds:

- **parameter** constraint - a restriction applied to option parameters
- **value** constraint - a restriction applied to the parsed value(s)

## Attribute classes

This section classifies attributes according to the subset of option types to which they apply. The options themselves will be explained later in this page.

### Basic attributes

All options share a set of attributes in addition to their type. They are described below.

#### Option names

The `names` attribute lists the option names as they may appear on the command line (e.g., `-h` or `--help`). Names must not contain whitespace or the equals sign `'='{:ts}`, since this character can be used as option-parameter separator.

<Callout type="default">

This attribute can be safely omitted if the option may be specified through [positional] arguments, [standard input] or environment [data sources].

</Callout>

#### Preferred name

The `preferredName` attribute, if present, is displayed in error and help messages in cases where a name is not available, e.g., when evaluating option requirements or processing positional arguments.

<Callout type="info">

This attribute is not validated, so it can be any string. If not specified, the first name in the `names` array will be used (notice that it is not marked as `readonly`).

</Callout>

#### Option synopsis

The `synopsis` attribute, if present, specifies a brief summary of the option's purpose, which will be formatted in the help message according to [text formatting] rules.

#### Deprecation notice

The `deprecated` attribute, if present, specifies the reason for the option being deprecated, which will be formatted in the help message according to [text formatting] rules.

<Callout type="default">

Deprecated options specified on the command line generate a [warning message], which you may want to print in the terminal. It can be obtained by destructuring the result of the parser's [`parseInto`] method.

</Callout>

#### Group | hide

The `group` attribute, if present, specifies the name of a group under which the option should appear in the help message. You can use the value `null{:ts}` instead, to completely hide it from the help message.

<Callout type="default">

You can assign a unique group to the [positional] option (if there is one) and place it _first_ in the option definitions, in order to highlight it in the help message.

</Callout>

#### Display styles

The `styles` attribute, if present, specifies custom [styling attributes] for the option's [help entry]. It has the following optional properties:

- `names` - the style of the option names
- `param` - the style of the option parameter
- `descr` - the style of the option description

#### Hyperlink

The `link` attribute, if present, specifies the URL of an external resource or media that will be included in the help message.

### Message attributes

Both the help and version options share the attribute described below.

#### Save message

By default, the option will _throw_ the message, as a convenient way for the application to print it in the terminal. However, this behavior can be changed with the `saveMessage` attribute. If present, it indicates that the message should be saved as the option value instead of being thrown.

### Value attributes

All options that may have a value share a set of attributes, which are described below.

#### Cluster letters

The `cluster` attribute, if present, specifies letters that can be used to combine options into a single command-line argument. This feature is also known as [short-option] style, and can be enabled via the parser's [`clusterPrefix`] configuration flag.

<Callout type="info">

This attribute is validated against the same regex as the [option names].

</Callout>

Here is an example that illustrates how it works. Suppose we have the following options:

- [flag] option, with name `'--flag'{:ts}` and letters `'fF'{:ts}`
- [single] option, with name `'--str'{:ts}` and letters `'sS'{:ts}`
- [array] option, with name `'--num'{:ts}` and letters `'nN'{:ts}`

Given these options, the following invocations would be equivalent:

```sh
cli -fSN 'my string' 1 2 3
cli -Fsn 'my string' 1 2 3
```

They would be transformed into their "canonical" form, i.e.:

```sh
cli --flag --str 'my string' --num 1 2 3
```

Notes about this feature:

- the _order_ of options in a cluster is preserved when converting to the canonical form
- variadic options and subcommands are supported, but they must come _last_ in a cluster
- if word completion is attempted for a cluster, the default completion message is thrown
- if a nameless positional option appears in a cluster, its argument will be treated as positional
- the cluster prefix can be the empty string, similarly to how the `tar` command works

##### Inline parameters

Cluster arguments may be considered to have an inline parameter if they contain at least one unknown letter that is _not_ the first. For example, using the same option definitions as above, the command line `cli -s'my str' -n123{:sh}` would be parsed as `cli --str 'my str' --num 123{:sh}`.

Notice how the parameters appear "glued" to the cluster letter, with no intervening space, and they contain characters that are not valid cluster letters. However, the first letter _must_ be valid for the argument to be considered a cluster argument.

<Callout type="info">

This feature is affected by the [inline constraint].

</Callout>

#### Always required

The `required` attribute, if present, indicates that the option is _always_ required, regardless of other options.

<Callout type="info">

Mutually exclusive with [default value] and [conditional requirements].

</Callout>

<Callout type="default">

When using this attribute, we recommend also setting [preferred name] to some explanatory name.

</Callout>

#### Forward requirements

The `requires` attribute, if present, specifies requirements that must be satisfied _if_ the option is specified on the command line. It can be either:

- an option **key**;
- an object that maps option keys to required **values**;
- a requirement **expression**; or
- a requirement **callback**

In the case of an option key, the referenced option must also be present on the command line. In the case of an object, every referenced option must have the corresponding value, which can be any value accepted by that option, or one of the special values:

- `undefined{:ts}` to signify _presence_
- `null{:ts}` to signify _absence_

<Callout type="info">

You cannot reference options from a [subcommand] (parent or child) in a requirement. Option keys must always refer to options in the same level of option definitions.

</Callout>

##### Requirement expression

You can also specify an expression, in which case it is evaluated as follows:

- `req.all{:ts}` - an expression that is satisfied when _all_ requirements are satisfied
- `req.one{:ts}` - an expression that is satisfied when at least _one_ requirement is satisfied
- `req.not{:ts}` - an expression that is satisfied when the requirement is _not_ satisfied.

##### Requirement callback

You can also specify a custom callback to evaluate requirements. It receives a single parameter which contains the parsed values, and should return a `boolean{:ts}` indicating whether the requirements were satisfied.

<Callout type="info">

This callback can be asynchronous.

</Callout>

It may be configured with a custom `toString` method to render it in error and help messages, e.g.:

```ts
options.flag.requires.toString = () => 'this and that ...';
```

<Callout type="default">

The callback may perform any kind of verification, such as inspecting parsed values, checking the environment, etc.

</Callout>

#### Conditional requirements

The `requiredIf` attribute is reciprocal to the previous one: if present, it specifies requirements which must be satisfied for the affected option to be _considered_ required.

<Callout type="info">

Mutually exclusive with [always required].

</Callout>

An example might help elucidate this distinction. Suppose we have these requirements:

```ts
req.all(
  'option1',
  req.one({ option2: null }, req.not({ option3: [2] })),
  (values) => values['option1'] === values['option3'],
);
```

If they were defined in the `requires` attribute, they would mean:

> _If this option is specified, then the following must hold true: `option1` must be present AND (`option2` must be absent OR `option3` must have a value different than `[2]`) AND `option1` must have the same value as `option3`._

And if they were defined in the `requiredIf` attribute, they would mean:

> _If `option1` is present AND (`option2` is absent OR `option3` has a value different than `[2]`) AND `option1` has the same value as `option3`, then this option is considered required and must be specified._

<Callout type="info">

An option is considered specified if it appears either on the command line, the [standard input] or an environment [data source].

</Callout>

#### Default value

The `default` attribute, if present, specifies a value to be used at the end of the parsing loop, in case the option is not specified in any of the following:

- the command line;
- the [standard input];
- an environment [data source]

<Callout type="info">

Mutually exclusive with [always required].

</Callout>

##### Default callback

If the default value is not known beforehand (e.g., if it depends on the values of other options), you can use a callback to inspect parsed values and determine the default value based on those.

It receives a single parameter which contains the parsed values, and should return the option value.

<Callout type="info">

This callback can be asynchronous.

</Callout>

When rendering a help message, the formatter disregards any value returned by the callback, as it may depend on the values parsed from command-line arguments, which are not available when processing the help option.

On the other hand, the callback can be configured with a custom `toString` method, e.g.:

```ts
options.flag.default.toString = () => 'this and that ...';
```

#### Parse callback

The `parse` attribute, if present, specifies a [custom callback] to parse the option's parameter(s).

It may receive different kinds of information depending on the option type, but its second parameter always contains the current [sequence information], including the option's name, argument index and any previously parsed values.

<Callout type="info">

This callback can be asynchronous.

</Callout>

<Callout type="default">

Inside the callback you may check whether an option has been specified before it by comparing its value with `undefined{:ts}`. This works because default values are only set at the _end_ of the parsing loop.

</Callout>

### Environment attributes

Options that may read data from the environment share some attributes, as described below.

#### Accept input

The `stdin` attribute, if present, indicates that the option accepts data from the standard input. It will only have effect if the option is _not_ specified on the command line, otherwise the input stream will remain untouched.

The parser only reads _readily_ available data, i.e., it does not wait for _new_ input. This means that it can only extract data from redirected command outputs, not from interactive terminals. For that effect, you should use the [default callback] in conjunction with third-party prompting libraries.

<Callout type="info">

This attribute has precedence over [data sources].

</Callout>

<Callout type="default">

You can omit the [option names] or completely [hide] the option from the help message, if you want its value to be read _exclusively_ from the standard input.

</Callout>

#### Data sources

The `sources` attribute, if present, specifies names of environment sources from which the option value should be read, in case it is specified neither on the command line nor in the [standard input].

Sources are tried in the specified order. A `string{:ts}` means an environment _variable_, while a `URL{:ts}` indicates the path of a _local file_.

<Callout type="info">

If data is found in a source, the affected option will be considered as if specified on the command line, which has implications for evaluating the option's requirements.

</Callout>

#### Break loop

The `break` attribute indicates whether the parser should exit the parsing loop after returning from a [parse callback].

<Callout type="warning">

When setting this attribute, the requirements of all options specified up to the current [argument sequence] will be verified. Hence, you should make it clear in the help message that any options required by the affected one must be specified _before_ it.

</Callout>

### Parameter attributes

All non-niladic options share a set of attributes, which are described below.

#### Example value

The `example` attribute, if present, specifies a value to appear in the help message [parameter column].

<Callout type="info">

Mutually exclusive with [parameter name].

</Callout>

#### Parameter name

The `paramName` attribute, if present, specifies a name to appear in the help message [parameter column].

<Callout type="info">

Mutually exclusive with [example value].

</Callout>

#### Positional | marker

The `positional` attribute, if present, indicates that the option accepts _positional_ arguments. There may be at most _one_ option with this setting.

If set to `true{:ts}`, then any argument not recognized as an option name will be considered positional. If set to a string, then it acts as a positional marker, in which case all arguments that appear _beyond_ the marker will be considered positional.

<Callout type="default">

When using this attribute, we recommend also setting [preferred name] to some explanatory name.

</Callout>

#### Inline constraint

The `inline` attribute, if present, indicates the option's treatment of [inline parameters]. It can be either `false{:ts}` to disallow, or `'always'{:ts}` to _always_ require inline parameters. By default, parameters are allowed (but not required) to be inlined with option names.

#### Complete callback

The `complete` attribute, if present, specifies a custom callback for [word completion], which can be used to make better suggestions than the built-in algorithm would for the option. It receives two parameters:

- `param` - the word being completed
- `info` - the current [sequence information]

It should return the list of completion words. If an error is thrown, it is ignored, and the default completion message is thrown instead.

<Callout type="info">

This callback can be asynchronous.

</Callout>

### Selection attributes

Both single- and array-valued options can have additional parameter constraints, for which they share a set of attributes as described below.

#### Regular expression

The `regex` attribute, if present, specifies a regular expression that the option's parameter(s) should match. Any parameter that does _not_ match the regex will cause an error to be raised.

<Callout type="info">

Mutually exclusive with [parameter choices].

</Callout>

#### Parameter choices

The `choices` attribute, if present, specifies string values that the option accepts as parameter. Any parameter that does not equal one of these values will cause an error to be raised. They are also considered by the [completion algorithm] when a parameter is being completed.

Alternatively, this attribute accepts a record that maps parameter values to option values. In this case, if a parameter fails to match one of the choices and the option has a [parse callback], it will be called for that parameter; otherwise, an error wil be raised.

<Callout type="info">

Mutually exclusive with [regular expression].

</Callout>

## Niladic options

Niladic options do not expect any parameter on the command line.

### Help option

The **help** option handles the formatting of help messages. Internally, it instantiates a [help formatter] with the provided configuration, obtains the formatted message and throws it. The application is responsible for catching this message and printing it in a terminal.

<Callout type="info">

When [word completion] is in effect, this option will be _skipped_.

</Callout>

In addition to the sets of [basic] and [message] attributes, this option has the attributes described below.

#### Formatter configuration

The `config` attribute specifies a custom [formatter configuration].

#### Help sections

The `sections` attribute specifies [help sections] to be rendered in the help message. By default, two sections are included:

- [usage section] - with `'Usage:'{:ts}` as heading, indented by 2 spaces
- [groups section] - with `'Options:'{:ts}` as the default group heading

#### Enable subcommand

The `useCommand` attribute is an opt-in feature that allows the next argument to be used as the name of a [subcommand] for which the help message should be generated. For example, the invocation `cli --help cmd` would throw the help of the `cmd` command, if it exists.

<Callout type="info">

If a subcommand with the specified name does not exist or does not have its own help, the argument may still be considered as an option filter when [enable option filter] is set.

</Callout>

#### Enable option filter

The `useFilter` attribute is an opt-in feature that allows the remaining arguments to be used as [option filter]. For example, the invocation `cli --help flag` would only include in the help message those options whose names, synopsis or environment [data sources] match the regex `/flag/i{:ts}`.

<Callout type="default">

The two features above may be used together. For example, the invocation `cli --help cmd -f` would throw the help message of the `cmd` subcommand, filtered by option `-f`.

</Callout>

### Version option

The **version** option throws a version message. In addition to the sets of [basic] and [message] attributes, it has the attributes described below.

<Callout type="info">

When [word completion] is in effect, this option will be _skipped_.

</Callout>

#### Version info

The `version` attribute specifies a semantic version or version information.

<Callout type="info">

Mutually exclusive with [resolve callback].

</Callout>

#### Resolve callback

The `resolve` attribute specifies a resolution function scoped to the [module] where a `package.json` file will be searched for and read to extract its `version` field. It is meant for use in non-browser environments and should generally have [`import.meta.resolve`] as value.

<Callout type="info">

Mutually exclusive with [version info].

</Callout>

### Command option

The **command** option -- a.k.a. subcommand -- lets you specify a set of option definitions for which the parser should process the remaining arguments.

It will supply the [parse callback] of the subcommand with the parsed values and subsequently exit the parsing loop. The option value will be either the result of the callback, if specified, or the parsed values themselves.

Values of _ancestor_ commands (i.e. non-immediate parents) cannot be accessed from within the callback. For this purpose, you will need to wait until the parser returns from the parsing loop.

<Callout type="info">

When [word completion] is in effect, the parse callback will _not_ be called, since completion will have occurred before it has a chance to execute.

</Callout>

In addition to the sets of [basic] and [value] attributes, it has the attributes described below.

#### Nested options | callback

The `options` attribute, if present, specifies a set of option definitions for the subcommand.

Alternatively, a callback may be used to provide the definitions, which allows the implementation of [recursive commands]. An asynchronous callback may be used to dynamically load definitions from another module, in which case you can return the result of the `import{:ts}` directive.

<Callout type="warning">

All incoming arguments will be parsed using the option definitions from this attribute, not from the parent command. Hence, you should make it clear in the help message that all arguments pertaining to the subcommand must be specified _after_ it.

</Callout>

#### Cluster prefix

The `clusterPrefix` property indicates whether the command accepts cluster arguments. This must be used in conjunction with the [cluster letters] of the nested option definitions.

### Flag option

The **flag** option accepts no parameter, but has a value that will be either the result of the [parse callback], if specified, or `true{:ts}`. The callback receives a `string[]{:ts}` as first parameter, which holds _all_ the remaining command-line arguments, and should return the option value.

<Callout type="info">

Altering the string array inside the parse callback will have _no_ effect on the original command-line arguments, as it is just a copy.

</Callout>

<Callout type="default">

If you need a boolean-valued option that accepts a single parameter, use the [single] option instead. And to make the parameter optional, use the [function] option with a [parameter count] of `[0, 1]{:ts}`.

</Callout>

This option has the following sets of attributes:

- [basic] attributes
- [value] attributes
- [environment] attributes
- the attribute described below

<Callout type="info">

Previous versions of the library also provided a `negationNames` attribute, which specified alternate option names to turn the option value `false{:ts}` (e.g., _--no-flag_). This can now be achieved by inspecting the `name` property of the [sequence information] in the callback.

</Callout>

#### Skip count

The `skipCount` attribute indicates the number of remaining arguments to skip, after returning from the [parse callback]. Its value is meant to be changed by the callback.

It is useful in cases where the number of parameters is not known beforehand, and the callback wants to have control over where an [argument sequence] ends.

<Callout type="info">

If the number or parameters is _fixed_, prefer the [function] option instead.

</Callout>

Here is an example of how it might be used inside the callback:

```ts {6}
{
  // other attributes...
  parse(params) {
    const index = params.findIndex((val) => !val.startsWith('{')); // find first non-JSON param
    const count = index >= 0 ? index : params.length; // count how many there are
    this.skipCount = count; // <<-- tell the parser to skip them
    return params.slice(0, count).map((val) => JSON.parse(val)); // return the parsed values
  },
}
```

<Callout type="default">

When [word completion] is in effect, the last argument will be the word to complete. If it pertains to the current [argument sequence], you can throw a completion message from the callback.

</Callout>

## Non-niladic options

Non-niladic options accept one or more parameters on the command line.

### Single-valued option

The **single** option accepts a single parameter. Its value can be either the result of the [parse callback], one of the [parameter choices] or the parameter itself (by default).

The parse callback receives a `string{:ts}` as first parameter, which is the option parameter, and should return the option value.

This option has the following sets of attributes:

- [basic] attributes
- [value] attributes
- [environment] attributes
- [parameter] attributes
- [selection] attributes

### Array-valued option

The **array** option accepts multiple (zero or more) parameters. Its value is an array whose elements can be either the result of the [parse callback], one of the [parameter choices] or the parameters themselves (by default).

The parse callback receives a `string{:ts}` as first parameter, which is a single option parameter, and should likewise return the value of a single array element. The resulting array may be normalized according to value constraints.

This option has the following sets of attributes:

- [basic] attributes
- [value] attributes
- [environment] attributes
- [parameter] attributes
- [selection] attributes
- the attributes described below

#### Parameter separator

The `separator` attribute, if present, specifies a delimiter by which to split the option parameters. It can be either a string or a regular expression.

<Callout type="info">

When _not_ using this attribute, we recommend disabling [inline parameters] through the [inline constraint].

</Callout>

#### Remove duplicates

The `unique` attribute, if present, indicates that duplicate elements will be removed from the option value. This normalization is applied _before_ checking the [element count limit].

<Callout type="info">

Due to the nature of JavaScript's [Set], the order of elements is preserved (i.e., it reflects the order in which the arguments were parsed).

</Callout>

#### Append values

The `append` attribute, if present, indicates that the option allows appending elements to its value if specified multiple times on the command line. Value constraints, if enabled, are applied after appendage.

#### Element count limit

The `limit` attribute, if present, indicates the maximum allowed number of elements. Any [argument sequence] that causes the option value to _exceed_ the given limit (after removing duplicates) will cause an error to be raised.

### Function option

The **function** option exists solely for the purpose of being configured with an expected parameter count, and is the only option that can accept between zero and one parameter. Its value will be either the result of the [parse callback], if specified, or `null{:ts}`.

The parse callback receives a `string[]{:ts}` as first parameter, which contains the option parameters, and should return the option value.

This option has the following sets of attributes:

- [basic] attributes
- [value] attributes
- [environment] attributes
- [parameter] attributes
- the attribute described below

#### Parameter count

The `paramCount` attribute, if present, specifies the number of parameters that the option expects. It can have either of the following values:

- a positive **number**: the option expects exactly this amount (must be greater than one)
- a numeric **range**: the option expects between a minimum and a maximum count

<Callout type="warning">

If the data comes from the [environment], then the [parse callback] will receive a _single_ element as parameter, which may be less than the expected count. You should inspect the `index` property of the [sequence information], which should be `NaN{:ts}` in this case.

</Callout>

Note that the function option cannot have a [parameter separator], since it would conflict with the parameter count. To see why, consider the case where the minimum count is 2. Then, the second parameter would always be treated as such, regardless of whether it is the name of another option, _even if the previous argument had two delimited parameters_. This is because the parser does not look for delimiters when trying to form an [argument sequence].

{/* self references */}

[^1]: Rather than accepting parameters, it starts a new parsing context with the remaining arguments.

{/* option types */}

[help]: #help-option
[version]: #version-option
[command]: #command-option
[subcommand]: #command-option
[flag]: #flag-option
[single]: #single-valued-option
[array]: #array-valued-option
[function]: #function-option

{/* attribute classes */}

[basic]: #basic-attributes
[message]: #message-attributes
[value]: #value-attributes
[environment]: #environment-attributes
[parameter]: #parameter-attributes
[selection]: #selection-attributes

{/* basic attributes */}

[option names]: #option-names
[preferred name]: #preferred-name
[option synopsis]: #option-synopsis
[deprecation notice]: #deprecation-notice
[group]: #group--hide
[hide]: #group--hide
[display styles]: #display-styles
[hyperlink]: #hyperlink

{/* message attributes */}

[save message]: #save-message

{/* value attributes */}

[cluster letters]: #cluster-letters
[always required]: #always-required
[forward requirements]: #forward-requirements
[conditional requirements]: #conditional-requirements
[default value]: #default-value
[default callback]: #default-callback
[parse callback]: #parse-callback

{/* environment attributes */}

[environment]: #environment-attributes
[standard input]: #accept-input
[data source]: #data-sources
[data sources]: #data-sources
[break loop]: #break-loop

{/* parameter attributes */}

[example value]: #example-value
[parameter name]: #parameter-name
[positional]: #positional--marker
[inline constraint]: #inline-constraint
[complete callback]: #complete-callback

{/* selection attributes */}

[regular expression]: #regular-expression
[parameter choices]: #parameter-choices

{/* help attributes */}

[enable subcommand]: #enable-subcommand
[enable option filter]: #enable-option-filter

{/* version attributes */}

[version info]: #version-info
[resolve callback]: #resolve-callback

{/* command attributes */}

{/* flag attributes */}

{/* single attributes */}

{/* array attributes */}

[parameter separator]: #parameter-separator
[remove duplicates]: #remove-duplicates
[append values]: #append-values
[element count limit]: #element-count-limit

{/* function attributes */}

[parameter count]: #parameter-count

{/* parser references */}

[resulting object]: parser#option-values
[word completion]: parser#word-completion
[completion algorithm]: parser#completion-algorithm
[custom callback]: parser#custom-callbacks
[argument sequence]: parser#argument-sequence
[sequence information]: parser#sequence-information
[`parse`]: parser#using-a-newly-created-object
[`parseInto`]: parser#using-an-existing-object
[`clusterPrefix`]: parser#cluster-prefix
[inline parameters]: parser#inline-parameters

{/* formatter references */}

[help formatter]: formatter
[output format]: formatter#output-format
[help items]: formatter#help-items
[help item]: formatter#help-items
[help entry]: formatter#help-entries
[help sections]: formatter#help-sections
[usage section]: formatter#usage-section
[groups section]: formatter#groups-section
[parameter column]: formatter#parameter-column
[option filter]: formatter#option-filter
[formatter configuration]: formatter#formatter-configuration

{/* styles references */}

[styling attributes]: styles#styling-attributes
[text formatting]: styles#text-splitting
[warning message]: styles#warning-message

{/* validator references */}

[constraints validation]: validator#constraints-validation

{/* guides references */}

[recursive commands]: ../guides/subcommands#advanced-features

{/* external references */}

[Set]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
[Math]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math
[`import.meta.resolve`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta/resolve
[short-option]: https://www.linuxtopia.org/online_books/linux_tool_guides/tar_user_guide/Short-Options.html
[discriminant]: https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions
[module]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules
