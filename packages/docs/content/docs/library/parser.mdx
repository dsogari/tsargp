---
title: Parser - Library - Docs
---

import { Callout } from 'nextra/components';

# Parser

The `ArgumentParser` class is the main library component. It can be instantiated with a set of
option _definitions_ and provides methods to parse command-line arguments into option values.

## Option values

The result of argument parsing is an object whose properties are the option values, one for each of
the option definitions given in the parser constructor. There are two ways to obtain these values,
as explained below.

### Using a newly-created object

The `parse` method returns a promise that resolves to the option values, and accepts two optional
parameters:

- `cmdLine` - the raw command line or the list of command-line arguments
- `flags` - an object containing the [parsing flags]

Normally you should _not_ need to pass these parameters, as they have sensible default values. The
command line defaults to the value of either the `COMP_LINE` or `BUFFER` environment variables
(whichever is present) or to the process arguments:

```ts
process.env['COMP_LINE'] ?? process.env['BUFFER'] ?? process.argv.slice(2);
```

If you feel the need to configure the parsing procedure, make sure to first understand how [word
completion] works.

<Callout type="info">
  This method is asynchronous, so you must use `await{:ts}` in order to resolve the returned
  promise.
</Callout>

### Using an existing object

This is a more flexible method that allows you to pass an existing object or class instance, which
will be filled with the parsed values. Existing values are preserved until they get overridden by
the parsing procedure. This method is named `parseInto` and accepts the same parameters as the
previous one, except for an additional (first) parameter:

- `values` - the option values to parse into

When using TypeScript, this object will be type-checked against the expected type of the option
values for a given set of option definitions. You can use the `valuesFor` function to create a new
object just before calling this method.

This method returns a promise that resolves to a `ParsingResult` object containing the following
properties:

- `warning` - a compilation of [warning messages] generated by the parser, if any

## Parser configuration

The parser can be configured via a `ParserConfig` object, which can be provided as an additional
parameter to the parser constructor. It contains the same properties as the [message configuration],
as well as the property described below.

### Error phrases

The `phrases` property specifies [custom phrases] to use for error and warning messages. Its
properties are optional and are indexed by the `ParsingError` enumeration, which lists the kinds of
errors and warnings that may be produced by the parser. They are summarized in the table below:

| Parsing error                | Raised when                                                                                   | Default phrase                                                                                       | Format specifiers                                                                                                            |
| ---------------------------- | --------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| `unknownOption`              | An option name is not found, with possible name suggestions                                   | `'Unknown option #0.(\| Similar names are: #1.)'{:ts}`                                               | `#0` = the unknown option name; `#1` = the similar names                                                                     |
| `unsatisfiedRequirement`     | An option's forward requirement is not satisfied                                              | `'Option #0 requires #1.'{:ts}`                                                                      | `#0` = the specified option name; `#1` = the option's requirements                                                           |
| `missingRequiredOption`      | An option that is always required was not specified                                           | `'Option #0 is required.'{:ts}`                                                                      | `#0` = the option's preferred name                                                                                           |
| `mismatchedParamCount`       | An option is specified with the wrong number of parameters                                    | `'Wrong number of parameters to option #0: requires (exactly\|at least\|at most\|between) #1.'{:ts}` | `#0` = the specified option name                                                                                             |
| `missingPackageJson`         | A "package.json" file could not be found when resolving the package version                   | `'Could not find a "package.json" file.'{:ts}`                                                       |                                                                                                                              |
| `disallowedInlineParameter`  | An option is specified with an inline parameter, despite it being disallowed                  | `'(Option\|Positional marker) #0 does not accept inline parameters.'{:ts}`                           | `#0` = the specified option name or positional marker                                                                        |
| `choiceConstraintViolation`  | An option parameter fails to satisfy a choice constraint                                      | `'Invalid parameter to #0: #1. Value must be one of: #2.'{:ts}`                                      | `#0` = the option's key or specified name; `#1` = the specified value; `#2` = the enum values or the truth and falsity names |
| `regexConstraintViolation`   | An option parameter fails to satisfy a regex constraint                                       | `'Invalid parameter to #0: #1. Value must match the regex #2.'{:ts}`                                 | `#0` = the option's key or specified name; `#1` = the specified value; `#2` = the regular expression                         |
| `limitConstraintViolation`   | An option value fails to satisfy a count limit constraint                                     | `'Option #0 has too many values: #1. Should have at most #2.'{:ts}`                                  | `#0` = the option's key or specified name; `#1` = the element count; `#2` = the count limit                                  |
| `deprecatedOption`           | A deprecated option is specified on the command-line                                          | `'Option #0 is deprecated and may be removed in future releases.'{:ts}`                              | `#0` = the specified option name                                                                                             |
| `unsatisfiedCondRequirement` | An option's conditional requirement is not satisfied                                          | `'Option #0 is required if #1.'{:ts}`                                                                | `#0` = the specified option name; `#1` = the option's requirements                                                           |
| `invalidClusterOption`       | Either a variadic option or a command option is specified in the middle of a cluster argument | `'Option letter #0 must be the last in a cluster.'{:ts}`                                             | `#0` = the specified cluster letter                                                                                          |
| `missingInlineParameter`     | An option is specified with no inline parameter, despite it being required                    | `'Option #0 requires an inline parameter.'{:ts}`                                                     | `#0` = the specified option name                                                                                             |

<Callout type="info">Phrases are formatted according to [text formatting] rules.</Callout>

## Parsing flags

The parsing procedure can also be configured with a `ParsingFlags` object that has some optional
properties, as described below.

### Program name

The `progName` property is a custom name for the main command, which is used to update the [process
title] and is rendered in the help message's [usage section]. It defaults to the basename of the
executing script, but can be suppressed by setting it to an empty string.

<Callout type="info">This flag is ignored when word completion is in effect.</Callout>

### Completion index

The `compIndex` property is the cursor position in a command line for which the user pressed `Tab`.
It defaults to the value of either the `COMP_POINT` or `CURSOR` environment variables, or to the
length of the `BUFFER` variable (whichever is present, otherwise undefined):

```ts
Number(process.env['COMP_POINT'] ?? process.env['CURSOR']) || process.env['BUFFER']?.length;
```

When invoking the parsing methods with a raw command line, and this flag is set, the parser will
know to perform word completion for the argument ending at this position.

### Cluster prefix

The `clusterPrefix` property specifies the prefix for cluster arguments. If set, then eligible
arguments with this prefix may be considered a cluster. This must be used in conjunction with the
[cluster letters] option attribute.

<Callout type="info">
  Option names have precedence over the cluster prefix. For example, if the prefix is a single dash
  and there's an option named `'-flag'{:ts}`, then an argument with this name will _not_ be
  considered a cluster argument.
</Callout>

## Parsing features

The set of features supported by the parser are described below.

### Custom callbacks

Custom parsing operations are supported through the following kinds of callbacks:

- [requirement callback]
- [default callback]
- [parse callback]
- [complete callback]

All of these can be asynchronous, in which case the parser awaits their resolution, either because
it needs their result or to avoid data races when reading and modifying the option values.

Note that there is no synchronous version of the parsing procedure. This is a design choice: in
order to support a fully synchronous `parse` method using the same code base, the parser would have
to deal with returned promises in a way that would make it hard to maintain (remember the classic
[callback hell]).

Besides, the asynchronous version has the benefit of allowing us to perform some operations, such as
[requirements checking], concurrently. This should not be a drawback for most applications, since
argument parsing is usually done at the top-level of a module or script, where the `await{:ts}`
directive is available.

### Argument sequence

An argument sequence is the occurrence of an option in the command line with possible parameters.
The parser looks for option names or positional arguments once it finishes parsing the previous
option, or if the latter is variadic.

For example, if the option initiating a sequence is an array-valued option, the parser starts
looking for new options as soon as it advances to the next argument, since that may be either an
option parameter or the start of a new sequence. Supposing that it is a parameter, once the parser
advances past this argument, it knows that the next one must be the start of a sequence.

The same algorithm works for function options with a variable [parameter count]. For example, if the
option expects between 1 and 3 parameters, the parser treats the next argument as a parameter to the
option, regardless of whether it is an option name or not. Once the first parameter is saved, the
parser resumes searching until 3 parameters are accumulated, at which point it _must_ find an option
specification (even if it is a new occurrence of the same option).

#### Sequence information

The information gathered by the parser is saved in an object that is passed as parameter to some of
the [custom callbacks]. It contains details about the current argument sequence in the parsing loop:

- `values` -
  The previously parsed values. It has an opaque type that should be cast to
  `OptionValues<typeof your_options>{:ts}`.
- `index` -
  The index of the occurrence of the option name, or of the first option parameter. It will be
  `NaN{:ts}` if the sequence comes from environment data.
- `name` -
  The option name as specified on the command-line, or the environment data source. It will be the
  option's [preferred name] if the sequence comes from positional arguments, or the string
  `'0'{:ts}` if it comes from the standard input.
- `comp` -
  True if performing word completion. Only available for the [parse callback], except that of a
  nested [command].
- `prev` -
  The option parameters preceding the word being completed, if any. Only available to the [complete
  callback].
- `format` -
  A utility function to create [terminal strings] with a formatted message. Only available to the
  [parse callback].

### Word completion

Quoting the [Bash docs]:

> When word completion is attempted for an argument to a command for which a completion
> specification (a compspec) has been defined using the `complete` builtin (see Programmable
> Completion Builtins), the programmable completion facilities are invoked.

The parser does not use the completion facilities, because it relies on the raw command line and the
cursor position into that line, which can be retrieved from the following environment variables:

- `COMP_LINE` or `BUFFER` - the current command line
- `COMP_POINT` or `CURSOR` - the index of the cursor position relative to the beginning of the
  command line

When these variables are available, the parser enters into _completion_ mode: it truncates the
command line at the cursor position and performs completion of the last argument.

The result of completion is a list of words separated by line breaks, which should be printed on the
terminal so that the completion builtins can perform the final completion step.

<Callout type="info">
  The parser ignores any errors thrown by callbacks during completion. If an error is thrown by a
  completion callback, the default [completion message] (an empty list) will be thrown instead.
</Callout>

#### Completion algorithm

The completion algorithm implemented by the library is explained below. In what follows, _comp_ is
the word being completed, i.e., the command-line argument ending at the completion index (it may be
an empty string):

1. If _comp_ is expected to be an option name:
   - If _comp_ is a known option name, that name is returned; else
   - If there is no positional option, the available option names are filtered by the prefix _comp_
     and returned; else
   - _comp_ is treated as a parameter of the positional option; go to step 2
2. _comp_ is the parameter of a non-niladic option, then either of the following is executed and its
   result is combined with that of step 3:
   - If the option has a [complete callback], it is called with _comp_; else
   - If it has [parameter choices], they are filtered by the prefix _comp_; else
   - An empty list is returned
3. If the option was specified neither with a [positional marker] nor as an [inline parameter],
   then, if either of the following holds true, the available option names are filtered by the
   prefix _comp_ and returned:
   - It is the first argument in a sequence of positional arguments; or
   - It is not short of the minimum expected parameter count of an option

If all of the above results in an empty list, the default completion (usually file completion, if
enabled in the builtin's configuration) will be attempted.

#### Altered parsing behavior

Since the completion builtins always expect a list of words as a result, the library must suppress
all errors that occur during parsing, and it does not make sense to perform some operations that
might throw. Therefore, when word completion is in effect, parsing behavior will change in the
following important ways:

- parsing errors, such as unknown option names, are suppressed
- message-valued options (help and version) are skipped
- nested commands' [parse callback] do not get executed
- option requirements are not verified
- cluster arguments are completed with the default completion (an empty list)

<Callout type="default">
  Other arguments are processed as usual, which means that a completion callback can inspect the
  values parsed before it, in order to make better suggestions based on those values.
</Callout>

### Requirements checking

When the parser evaluates option requirements, it compares an option's value against any value
required by other options. Generally, this analysis is performed after all arguments have been
parsed, but it may also be performed in two more situations:

- before calling the [parse callback] of an option that has [break loop] set
- before calling a [command callback]

<Callout type="info">
  As has been mentioned, requirements are _not_ checked when word completion is in effect.
</Callout>

### Name suggestions

When the parser expects an option name and the current argument is not a valid one (and there is no
positional option), it may select option names that are similar to the current argument using the
[Gestalt algorithm], and include them in the error message.

### Inline parameters

Option parameters may be passed on the command-line using the syntax `<name>=<param>`. As is the
case with standalone parameters, inline parameters may contain any number of equal signs, and even
start with one (e.g., `-opt==val` would be parsed as `'=val'{:ts}`).

<Callout type="info">This syntax cannot be used with the positional marker.</Callout>

Cluster arguments may also have inline parameters, but their syntax is different. A cluster argument
is considered to have an inline parameter if it contains an unknown letter that is not the first one
in the cluster. In this case, the first letter _must_ be an option and the rest is its parameter.
See [cluster inline parameters] for details about this syntax.

### Process title

The process title will be updated to reflect the current command being executed. This includes the
main script and any nested commands. For example, if the command-line is:

```sh
path/to/main/script.js -flag0 cmd1 -flag1 cmd2 args...
```

The process title would be updated in the following way:

1. `node` - the starting title, before any updates
2. `node script.js` - the title at the beginning of the parsing loop
3. `node script.js cmd1` - the title at the start of the `cmd1` command
4. `node script.js cmd1 cmd2` - the title at the start of the `cmd2` command

The title will remain unchanged after the parser returns. Other option names are not used, because
they would pollute the output of process management utilities such as `ps`.

[parsing flags]: #parsing-flags
[word completion]: #word-completion
[process title]: #process-title
[requirements checking]: #requirements-checking
[inline parameter]: #inline-parameters
[custom callbacks]: #custom-callbacks

{/* options references */}
[parameter count]: options#parameter-count
[parameter choices]: options#parameter-choices
[command]: options#command-option
[break loop]: options#break-loop
[cluster letters]: options#cluster-letters
[cluster inline parameters]: options#inline-parameters
[preferred name]: options#names--preferred-name
[requirement callback]: options#requirement-callback
[default callback]: options#default-callback
[parse callback]: options#parse-callback
[complete callback]: options#complete-callback
[positional marker]: options#positional--marker

{/* styles references */}
[message]: styles#terminal-messages
[custom phrases]: styles#custom-phrases
[message configuration]: styles#message-configuration
[warning messages]: styles#warning-message
[completion message]: styles#completion-message
[terminal strings]: styles#terminal-strings

{/* formatter references */}
[usage section]: formatter#usage-section

{/* external references */}
[Set]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
[Bash docs]: https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html
[Gestalt algorithm]: https://www.wikiwand.com/en/Gestalt_pattern_matching
[callback hell]: http://callbackhell.com/
