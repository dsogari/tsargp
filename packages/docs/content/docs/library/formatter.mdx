---
title: Formatter - Library - Docs
---

import { Callout } from 'nextra/components';

# Formatter

The `HelpFormatter` component handles formatting of help messages. It can be instantiated with a set of option _definitions_ and provides methods to render help messages in ANSI format.

## Help message

Internally, the help message consists of [ANSI strings] that may contain escape sequences and are meant to be printed in a terminal. Visually, it can be divided into the following content parts:

- **section** - a group of text lines, like the section of a document
- **entry** - the lines pertaining to an option definition
- **item** - a single piece of information in an option's description
- **group** - a set of entries corresponding to an option [group]
- **column** - a horizontal division (as formed by a vertical ruler) across all entries of all groups

There are two main ways of obtaining help messages, as described below.

### Grouped help

The `format` method returns the help message of an option group. It accepts a single optional parameter: the name of the group. If not provided, the _default_ group is used, which corresponds to the set of options that did not explicitly declare a [group] in their definition.

### Sectioned help

The `sections` method returns a help message that includes [help sections], as will be explained later in this page. It accepts two parameters:

- `sections` - a list of `HelpSection`s to include in the help message
- `progName` - an optional program name to display in usage sections

## Message configuration

The help messages produced by the formatter can be configured via the [message configuration], which can be provided as the second parameter to the formatter constructor.

## Help entries

Each option definition results in a help entry under its respective group in the help message. An entry is divided into "columns" (not to be confused with terminal columns), each containing a piece of information, as described below.

### Names column

This column contains the options' names separated by commas. The names are listed in the same order as was specified in the [names] attribute.

#### Name slots

Depending on the column's [alignment] setting, each option name may reserve a "slot" in the respective position in this column. The length of a name slot will be the length of the largest name in that slot, among all options. Empty strings or `null{:ts}`s can be specified in order to skip a slot.

For example, if an option's names are `'-f'{:ts}`, `'-ff'{:ts}`, `''{:ts}` and `'--flag'{:ts}`, the resulting entry might be formatted as:

```
-f, -ff      --flag
```

Note how the empty string produced whitespace between its neighbors, and the commas were suppressed.

### Parameter column

This column contains either the option's `type`, the [example value] or the [parameter name]. It is rendered in the following way:

- if the option:
  - is [niladic], it is omitted
  - contains an example value, this value is used
  - is a command option, it is rendered as an ellipsis `'...'{:ts}`
  - is a function option, `type` is replaced by the word `param`
  - does not have a parameter name containing an angle bracket `'<'{:ts}`, it is enclosed in angle brackets `'<>'{:ts}`
  - requires [inline parameters], it is prefixed with an equals sign `'='{:ts}`
  - accepts more than one parameter, it is suffixed with an ellipsis `'...'{:ts}`
  - can be specified without parameters, it is enclosed in square brackets `'[]'{:ts}`

The result might be something like `=<param>` or `[<param>...]`.

### Description column

The last column contains the option description and is composed of [help items], which are explained later in this page.

## Help sections

Sections are a convenient way to organize the help content. There are three kinds of help sections: **text**, **usage** and **groups**. They are explained below.

### Common properties

All help sections share a set of properties:

- `title` - the section heading or the default option group heading (defaults to none)
- `style` - the style of the section heading or option group headings (defaults to `tf.bold{:ts}`)
- `breaks` - the number of line breaks to insert before the section (defaults to `0{:ts}` for the first section, else `2{:ts}`)
- `noWrap` - true to disable wrapping of provided texts (defaults to `false{:ts}`)

<Callout type="info">

Even if `noWrap` is set, inline styles may still be used in text properties, although they will _not_ be formatted according to the [text formatting] rules.

</Callout>

<Callout type="info">

All headings are separated from their content by _two_ line feeds, unless extra spacing is provided in heading texts. For the sake of simplicity, there is no way to configure this behavior.

</Callout>

### Text section

A text section can be used to write many kinds of content, such as an introductory text, usage instructions, afterword, copyright notice or external references. In addition to the [common properties], it has the following properties:

- `text` - the section content
- `indent` - the level of indentation of the section content (defaults to `0{:ts}`)

### Usage section

The usage text is a concise representation of a program's command-line. Here is an example:

{/* cSpell:disable */}

```ansi
demo.js [([95m-h[0m|[95m--help[0m)] [([95m-v[0m|[95m--version[0m)] [32m# get help[0m
demo.js [0m[95mhello[0m [90m...[0m [32m# execute the hello command[0m
demo.js [([95m-f[0m|[95m--flag[0m|[95m--no-flag[0m)]
        [([95m-b[0m|[95m--boolean[0m) [90m<boolean>[0m]
        [([95m-s[0m|[95m--stringRegex[0m) [90m<my str>[0m]
        [([95m-n[0m|[95m--numberRange[0m) [90m<my num>[0m]
        [([95m-se[0m|[95m--stringEnum[0m) [32m'one'[0m]
        [([95m-ne[0m|[95m--numberEnum[0m) [33m1[0m]
        [([95m-ss[0m|[95m--strings[0m) [90m[<strings>][0m]
        [([95m-ns[0m|[95m--numbers[0m) [90m<numbers>...[0m]
        [[([95m--stringsEnum[0m|[95m--[0m)] [32m'one'[0m [32m'two'[0m]
        [[95m--numbersEnum[0m [32m'1,2'[0m]
```

{/* cSpell:enable */}

In addition to the [common properties], a usage section has the following properties:

- `indent` - the level of indentation of the section content (defaults to `0{:ts}`)
- `filter` - a list of option keys to include or exclude (defaults to including all options)
- `exclude` - whether the filter should exclude (defaults to `false{:ts}`)
- `required` - a list of options that should be considered _always_ required
- `requires` - a map of option keys to required options (defaults to none)
- `comment` - a commentary to append to the usage (defaults to none)

<Callout type="default">

The filter can be used to create multiple usages of the same command, with different options.

</Callout>

<Callout type="info">

In the case of an inclusion filter, options are listed in the same order specified in the filter.

</Callout>

#### Option dependencies

The `requires` property is equivalent to an adjacency list, except that each source can only reference a single target. Mutually dependent options are supported. The following table lists some examples that illustrate how this works. Suppose we have options A, B and C. Then:

| Dependencies                       | Usage         | If C is always required |
| ---------------------------------- | ------------- | ----------------------- |
| A requires B requires C            | `[[[A] B] C]` | `[[A] B] C`             |
| A and B require each other         | `[A B] [C]`   | `[A B] C`               |
| A requires B requires C requires A | `[A B C]`     | `A B C`                 |
| A and C require B                  | `[[A] B [C]]` | `[A] B C`               |
| A requires B; C requires A         | `[[A [C]] B]` | `A C B`                 |

<Callout type="info">

Mutual exclusivity and multi-targeting are _not_ supported at this time. For that purpose, you have to create different usages. (The reason is that it is difficult to implement. We sincerely apologize.)

</Callout>

### Groups section

A groups section is a collection of option groups and their help entries. In addition to the [common properties], it has the following properties:

- `filter` - a list of group names to include or exclude (defaults to including all groups)
- `exclude` - whether the filter should exclude (defaults to `false{:ts}`)

<Callout type="info">

In the case of an inclusion filter, groups are listed in the same order specified in the filter.

</Callout>

## Help layout

The layout of the help message can be configured via a `PartialHelpLayout` object, which can be provided as the third parameter to the formatter constructor. It contains the properties described below.

### Help columns

The `names`, `param` and `descr` properties specify settings that can be used to customize the format of the corresponding [help column], for all help entries. They are objects with the following optional properties:

- `align` - text alignment for the column (may be one of `'left'{:ts}` or `'right'{:ts}`, defaults to `'left'{:ts}`)
- `indent` - level of indentation for the column (must be non-negative if `absolute` is `true{:ts}`, defaults to `2{:ts}`)
- `breaks` - number of line breaks to insert before each entry in the column (defaults to `0{:ts}`)
- `hidden` - whether the column should be hidden (defaults to `false{:ts}`)
- `absolute` - whether the indentation level should be relative to the beginning of the line instead of the end of the previous column (not available for the names column, defaults to `false{:ts}`)

The `names.align` property supports an additional value `'slot'{:ts}`, which means that each name receives a "slot" in the column, and the name is left-aligned within that slot. See [name slots] for more information.

The `param.align` and `descr.align` properties support an additional value `'merge'{:ts}`, which instructs the formatter to merge the contents of the column with the previous one. This is useful, for instance, if you want option parameters to be inlined with option names. When using this value, both the `indent` and `breaks` properties are ignored.

An example can better illustrate the effect of some of these settings. Suppose we have the following configuration:

```ts
{
  names: {
    align: 'slot',  // assign a slot to each option name
  },
  param: {
    breaks: 1,      // break option parameters
    indent: -10,    // recede 10 terminal columns from the end of the names column
  },
  descr: {
    align: 'right', // align option descriptions to the right
    breaks: 1,      // break option descriptions
    indent: 20,     // indent 20 terminal columns
    absolute: true, // ...from the beginning of the line
  }
}
```

The following is an extract of a help message produced with these settings:

{/* cSpell:disable */}

```ansi
  [95m-ne[0m,   [95m--numberEnum[0m
            [33m1[0m
                             [0mA number option. Values must be one of {[33m1[0m, [33m2[0m}.[0m
  [95m-ns[0m,   [95m--numbers[0m
            [90m[<param>...][0m
                      [0mA numbers option. Accepts multiple parameters. Values
                    must be in the range [[33m0[0m, [33mInfinity[0m]. Defaults to [[33m1[0m, [33m2[0m].[0m
```

{/* cSpell:enable */}

### Help items

The `items` property specifies the kinds of help items that should be displayed in option descriptions, and in which order. It is an array whose values can be one of the enumerators from `HelpItem`. The default is to print all items in the order listed in the enumerator type.

<Callout type="default">

You might want to use this to limit the amount of information in the help message.

</Callout>

## Option filter

The formatter constructor accepts a fourth optional parameter, which specifies a list of patterns to select the options that will be rendered in the help message. The filter matches options' names, synopsis and environment data sources. If multiple patterns are provided, any matched one will suffice to include an option in the message.

<Callout type="default">

This is inherently different from what a text search utility like `grep` would produce. The formatter will render the _whole_ help entry of options matching the given patterns, not just the matching lines.

</Callout>

{/* self references */}

[^1]: _polyadic_ means that the option accepts more than one parameter, but the parameter count is not variable

[help sections]: #help-sections
[help column]: #help-entries
[custom phrases]: #custom-phrases
[alignment]: #help-layout
[help items]: #help-items
[name slots]: #name-slots
[common properties]: #common-properties

{/* options references */}

[group]: options#group--hide
[names]: options#option-names
[example value]: options#example-value
[parameter name]: options#parameter-name
[niladic]: options#niladic-options

{/* parser references */}

[inline parameters]: parser#inline-parameters

{/* styles references */}

[ANSI strings]: styles#ansi-strings
[text formatting]: styles#text-splitting
[message configuration]: styles#message-configuration
