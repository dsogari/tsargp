---
title: Parser - Library - Docs
---

import { Callout } from 'nextra/components';

# Parser

The `ArgumentParser` class is the main library component. It can be instantiated with a set of
option _definitions_ and provides methods to parse command-line arguments into option values.

## Option values

The result of argument parsing is an object that contains the option values corresponding to the
option definitions given in the parser constructor. There are different ways to obtain these values,
as explained below.

### Using a newly-created object

This is the easiest, most common method: you just call `parse` and await the returned promise. This
method accepts two optional parameters:

- `cmdLine` - the raw command line (`string{:ts}`) or the command-line arguments (`string[]{:ts}`)
- `flags` - a `ParsingFlags` object with the [parsing flags]

Normally you should _not_ need to pass these parameters, as they have sensible default values:

- `cmdLine` - `process.env['COMP_LINE']{:ts}` or `process.argv.slice(2){:ts}`
- `flags.progName` - `process.argv[1].split(/[\\/]/).at(-1){:ts}`
- `flags.compIndex` - `Number(process.env['COMP_POINT']){:ts}`

If you feel the need to configure the parsing procedure, make sure to first understand how [word
completion] works.

<Callout type="info">
  This method is _asynchronous_, so you must use `await{:ts}` in order to resolve the returned
  promise.
</Callout>

### Using your own object

This is a more flexible method that allows you to pass an existing object or class instance, which
will be filled with the parsed values. It is named `parseInto` and accepts the same parameters as
the previous one, except for an additional (first) parameter:

- `values` - the option values to parse into

Existing values are preserved until they get overriden by values parsed either from the command-line
or from environment variables. When using TypeScript, this parameter will be type-checked against
the expected type of the option values for a given set of option definitions.

<Callout type="default">
  You may want to use IntelliSense to peak at the resulting type of the `parse` method (or declare a
  temporary type alias for `OptionValues<typeof _your_options_>{:ts}`) to see how the object is
  structured.
</Callout>

This method returns a promise that resolves to a `ParsingResult` object containing the following
properties:

- `warning` - a compilation of [warning messages] generated by the parser, if any

## Parsing flags

The parsing procedure can be configured with a `ParsingFlags` object that has some optional
properties, as described below.

### Program name

The `progName` property is a custom name for the program, which is used to update the [process
title] and is rendered in the help message's [usage section]. It defaults to the basename of the
executing script. You can set it to the empty string in order to suppress its appearance.

<Callout type="info">This flag is ignored when word completion is in effect.</Callout>

### Completion index

The `compIndex` property is the completion index of a raw command line. When supplying the parsing
methods with a command-line string, this value instructs the parser to perform word completion when
parsing the argument that overlaps this position in the string. It defaults to the value of the
`COMP_POINT` environment variable.

### Short-option style

The `shortStyle` property indicates whether the first argument is expected to be an option cluster.
This must be used in conjunction with the [cluster letters] option attribute.

## Parsing features

The parser supports an assortment of features that should fulfill most use cases. They are listed
below.

### Custom callbacks

Custom parsing operations are supported through the following kinds of callbacks:

- [requirement callback]
- [default callback]
- [parse callback]
- [complete callback]
- [function callback]
- [command callback]

All of these can be asynchronous, and the parser always awaits the resolution of returned promises,
either because it needs their result or to avoid data races when reading and modifying the option
values.

Note that there is no synchronous version of the parsing procedure. This is a design choice: in
order to support a fully synchronous `parse` method using the same code base, the parser would have
to deal with returned promises in a way that would make it hard to maintain (remember the classic
[callback hell]).

Besides, the asynchronous version has the benefit of allowing us to perform some operations
concurrently, such as the [requirements checking]. This should not be a drawback for most CLI
applications, since argument parsing is usually done at the top-level of a module or script.

### Argument sequence

An argument sequence is the occurrence of an option in the command line with possible parameters.
The parser looks for option names or positional arguments once it finishes parsing the previous
option, or if the latter is variadic.

For example, if the option initiating a sequence is a string option with a [fallback value], the
parser starts looking for new options as soon as it advances to the next argument, since that may be
either the option parameter or the start of a new sequence. Supposing that it is a parameter, once
the parser advances past this argument, it knows that the next one must be the start of a sequence.

The same algorithm works for function options with a variable [parameter count]. For example, if the
option expects between 1 and 3 parameters, the parser treats the next argument as a parameter to the
option, regardless of whether it is an option name or not. Once the first parameter is saved, the
parser resumes searching until 3 parameters are accumulated, at which point it _must_ find an option
specification (even if it is a new occurrence of the same option).

#### Sequence information

The information gathered by the parser is saved in a `ParseInfo` object that is passed as parameter
to some of the [custom callbacks]. It contains details about the current argument sequence in the
parsing loop:

- `values` -
  The previously parsed values. It has an opaque type that should be cast to
  `OptionValues<typeof your_options>{:ts}`.
- `index` -
  The index of the occurrence of the option name, or of the first option parameter. It will be
  `NaN{:ts}` if the sequence comes from an environment variable.
- `name` -
  The option name as specified on the command-line, or the environment variable name.
  It will be the option's [preferred name] if the sequence comes from positional arguments.
- `param` -
  The option parameter(s), or the parameters preceding the word being completed, if any.
- `comp` -
  True if performing word completion, or the word being completed. Not available for the [command
  callback].
- `isComp` -
  An additional property only available to the [function callback] to check whether any of the
  remaining arguments is to be completed, when `comp` is true. It accepts a single string parameter
  and returns the word to be completed, if any (it may be an empty string); otherwise it returns
  `undefined{:ts}`.

### Word completion

Quoting the [Bash docs]:

> When word completion is attempted for an argument to a command for which a completion
> specification (a compspec) has been defined using the `complete` builtin (see Programmable
> Completion Builtins), the programmable completion facilities are invoked.

The parser does not use the completion facilities, because it relies on the command line string and
the completion index into that string, which can be retrieved from the following environment
variables (available when performing completion):

- `COMP_LINE` - the current command line
- `COMP_POINT` - the index of the current cursor position relative to the beginning of the current
  command

The way it does this is by inserting a placeholder into the command-line argument that is under the
completion index. This placeholder is then looked for at each iteration in the parsing loop to know
when to perform completion.

The result of completion is a list of words separated by line breaks, and should be printed on the
terminal so that the `complete` builtin can perform the final completion step.

<Callout type="info">
  The parser ignores any errors thrown by callbacks during completion. If an error is thrown by a
  completion callback, the default [completion message] (an empty list) will be thrown instead.
</Callout>

#### Completion algorithm

The completion algorithm implemented by the library is explained below. In what follows, _comp_ is
the word being completed, i.e., the command-line argument ending at the completion index (it may be
an empty string):

1. If _comp_ is expected to be an option name:
   - If _comp_ is a known option name, that name is returned; else
   - If there is no positional option, the available option names are filtered by the prefix _comp_
     and returned; else
   - _comp_ is treated as a parameter of the positional option; go to step 2
2. _comp_ is the parameter of a non-niladic option, then either of the following is executed and its
   result is combined with that of step 3:
   - If the option has a [complete callback], it is called with _comp_; else
   - If it is a boolean option, the option's [truth and falsity] names (if any) are filtered by the
     prefix _comp_; else
   - If the option has [enumerated values], those values are converted to string and filtered by the
     prefix _comp_; else
   - An empty list is returned
3. If the option was not specified with a [positional marker], then, if either of the following
   holds true, the available option names are filtered by the prefix _comp_ and returned:
   - It is the first argument in a sequence of positional arguments; or
   - It is not the first argument in a sequence, and is not short of the minimum expected parameter
     count of an option

If all of the above results in an empty list, the default completion (if enabled with `complete -o`)
will be attempted. Note that the conditions of the third step exclude the possibility of it being an
[inline parameter], when considering option names.

During completion, both the help and version options are skipped, and the [command callback] does
not get executed. Other options are processed as usual, which means that a completion callback can
inspect the values parsed before it, in order to make better suggestions based on those values.

### Requirements checking

Generally, option requirements are evaluated after all arguments have been parsed. During this
analysis, an option's value is compared against any value required by other options. This check may
also be performed in two more situations:

- before calling a [function callback], if the function option's [`break`] attribute was set
- before calling a [command callback]

However, requirements are not checked when performing word completion. This is due to the fact that
the completion builtin always expects a list of words as a result. Hence, the library must suppress
any errors that occur during parsing and it does not make sense to verify requirements in that case.

### Name suggestions

When the parser expects an option name and the current argument is not a valid one (and there is no
positional option), it may select option names that are similar to the current argument using the
[Gestalt algorithm], and include them in the error message.

### Error messages

Error messages generated by the parsing procedure can be customized via the [validator
configuration], which can be provided as an additional parameter to the parser constructor.

### Inline parameters

Option parameters may be passed on the command-line using the syntax `<name>=<value>`. This syntax
is only valid for non-niladic options and cannot be used with the positional marker. As is the case
with normal parameters, the value may contain any number of equal signs, and even start with one
(e.g., `-opt==val` would be parsed as `'=val'{:ts}`).

### Process title

The process title will be updated to reflect the current command being executed. This includes the
main script and any nested commands. For example, if the command-line is:

```sh
./path/to/myscript.js -flag0 cmd1 -flag1 cmd2 args...
```

The process title would be updated in the following way:

1. `node` - this the starting title, before any updates
2. `node myscript.js` - the title at the beginning of the parsing loop
3. `node myscript.js cmd1` - the title at the start of the `cmd1` command
4. `node myscript.js cmd1 cmd2` - the title at the start of the `cmd2` command

The title will remain unchanged after the parser returns. Other option names are not used, because
they would pollute the output of process management utilities such as `ps`.

[parsing flags]: #parsing-flags
[word completion]: #word-completion
[process title]: #process-title
[requirements checking]: #requirements-checking
[inline parameter]: #inline-parameters
[custom callbacks]: #custom-callbacks
[valued option]: options#value-attributes
[message]: styles#terminal-messages
[append]: options#append-values
[enumerated values]: options#enumeration
[cluster letters]: options#cluster-letters
[remove duplicates]: options#remove-duplicates
[validator configuration]: validator#validator-configuration
[requirement callback]: options#requirement-callback
[default callback]: options#default-callback
[parse callback]: options#parse-callback
[complete callback]: options#complete-callback
[function callback]: options#function-callback
[command callback]: options#command-callback
[positional marker]: options#positional--marker
[warning messages]: styles#warning-message
[completion message]: styles#completion-message
[preferred name]: options#names--preferred-name
[truth and falsity]: options#truth--falsity-names
[fallback value]: options#fallback-value
[parameter count]: options#parameter-count
[usage section]: formatter#usage-section
[`break`]: options#break-loop
[Set]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
[Bash docs]: https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html
[Gestalt algorithm]: https://www.wikiwand.com/en/Gestalt_pattern_matching
[callback hell]: http://callbackhell.com/
