---
title: Parser - Library - Docs
---

import { Callout } from 'nextra/components';

# Parser

The `ArgumentParser` class is the main library component. It can be instantiated with a set of
option _definitions_ and provides methods to parse command-line arguments into option values.

## Option values

The result of argument parsing is an object that contains the option values corresponding to the
option definitions given in the parser constructor. There are different ways to obtain these values,
as explained below.

<Callout type="info">
  The initial value of any [valued option](options.mdx#value-attributes) is `undefined{:ts}`.
</Callout>

### Using a newly-created object

This is the easiest, most common method: you just call `parse` and use the returned object. This
method accepts two optional parameters:

- `command` - the raw command line (`string{:ts}`) or the command-line arguments (`string[]{:ts}`)
- `config` - the [parse configuration](#parse-configuration)

Normally you should _not_ need to pass these parameters, as they have sensible default values:

- `command` - `process.env['COMP_LINE']{:ts}` or `process.argv.slice(2){:ts}`
- `config.progName` - command name from `command` or `process.argv[1].split(/[\\/]/).at(-1){:ts}`
- `config.compIndex` - `Number(process.env['COMP_POINT']){:ts}` or `undefined{:ts}`

If you feel the need to configure the parser, make sure to first understand how
[bash completion](#bash-completion) works.

When declaring [async callbacks](#executing-callbacks) in the option definitions, you should call
the `parseAsync` method instead, which returns a promise that can be awaited in order resolve those
callbacks.

### Using your own class

This is a more flexible method that allows you to pass an existing object or class instance, which
will be filled with the parsed option values. The method is named `parseInto` and accepts the same
parameters as the previous one, except for an additional (first) parameter:

- `values` - the option values to parse into

Existing values are preserved until they get overriden by values passed either in the command-line
or in environment variables. When using TypeScript, this parameter will be type-checked at compile
time against the expected type of the option values for a given set of option definitions.

<Callout type="default">
  You may want to use IntelliSense to peak at the resulting type of the `parse` method (or declare a
  temporary type alias for `OptionValues<typeof _your_options_>{:ts}`) to see how the object is
  structured.
</Callout>

This method returns a promise that can be awaited in order to resolve
[async callbacks](#executing-callbacks).

### Getting warnings

This is the most flexible method and is similar to the above one, except that it returns a
`ParseResult` object with the following properties:

- `promises` - a list of promises to resolve the [async callbacks](#executing-callbacks)
- `warnings` - a list of [warning messages](styles.mdx#warning-message) generated by the parser

Both of these properties can be ignored if empty.

### Avoiding `try`/`catch`

This is a convenience method that accepts the same parameters as the previous one, except that it
catches any error or [message](styles.mdx#terminal-messages) thrown by the parser and returns it
instead. In the successful case, it compiles a single message from the list of warnings produced by
the parser and returns it.

There's just one caveat: it is an asynchronous method, so you should await its result in order to
use it. This is because errors may be thrown by [async callbacks](#executing-callbacks), and in
order to catch those, it must be done asynchronously.

## Parse configuration

The parsing procedure can be configured with a `ParseConfig` object that has a few optional
properties, as described below.

### Program name

The `progName` property is a custom name for the program, which is used to update the process title.
It defaults to the basename of the executing script (if no command-line is explicitly provided) or
to the command name (in case a raw command-line string is provided).

### Completion index

The `compIndex` property is the completion index of a raw command line. When supplying the parsing
methods with a command-line string, this value instructs the parser to perform bash completion when
parsing the argument that overlaps this position in the string.

## Asynchronous parsing

To understand how the parser supports asynchronous operations, we need to review the kinds of
callbacks that an option definition may declare. There are seven of them:

- [default callback](options.mdx#default-value--callback)
- [parse callback](options.mdx#parse-callback)
- [parse delimited](options.mdx#parse-delimited)
- [complete callback](options.mdx#complete-callback)
- [resolve callback](options.mdx#resolve-callback)
- [execute callback](options.mdx#execute-callback)
- [command callback](options.mdx#command-callback)

They can be categorized as either _parsing_ callbacks or _executing_ callbacks, and are further
explained below.

### Parsing callbacks

The default, parse and parse delimited callbacks can return promises. They may even return different
data types from one invocation to the next (e.g., a promise and a non-promise). To support these use
cases, the library checks the return type of each invocation to know if it is a promise or not, and
act accordingly.

In the case of the default callback, since there is no previous value to worry about, handling
promises is very simple: if the returned value is a promise, then it is chained with a callback
that normalizes the value, and the new promise becomes the option value; otherwise, the returned
value is normalized and set as the option value. This will also be the case of single-valued option
types, since these options do not need the previous value: it simply gets replaced.

Array-valued options, on the other hand, suffer from the fact that the parser always appends the
values it parses. This happens because the parser does not know in advance how many parameters there
will be for an option (although it ensures that the option value is reset to an empty array when it
encounters the option name, if the [append](options.mdx#append-values) attribute is not set). In
this case, there are four possible combinations of previous value and callback invocation result:

1. non-promise and non-promise
2. non-promise and promise
3. promise and promise
4. promise and non-promise

They are handled in following manner:

- The first case is handled by simply appending the normalized elements to the previous value, since
  it is a synchronous operation.
- The second and third cases are handled by chaining the returned promise with an async callback
  that appends the normalized elements to the (awaited) previous value.
- The fourth case is handled by chaining the existing promise with a callback that appends the
  normalized elements to the previous value.

Note that, for array-valued options, once a promise is returned from a parsing callback there's no
turning back to a non-promise.

<Callout type="info">
  A special case occurs when a variadic array option is specified on the command-line without
  parameters. In that case, the parser must initialize the option value to an empty array. This
  means that, even if an option declares an async parsing callback in its definition, the parser
  might exit the loop before calling the callback, thus leaving the value as an empty array
  (non-promise). This is not a problem, since the `await` expression can be called on a non-promise.
</Callout>

None of these cases make it necessary to call `parseAsync` or await the return of `parseInto`, since
the callback promises are _inside_ the resulting object. But you must await each value in this
object that is a promise, in order to obtain the value.

### Executing callbacks

The complete, resolve, execute and command callbacks are the ones that may cause the parser to
accumulate promises that will be returned by the `parseAsync` or `parseInto` methods, which then
need to be awaited in order to await their resolution.

In the case of the complete and resolve callbacks, once awaited, the promise throws a string that
should be caught and printed on a terminal. They are the version or the completion words,
respectively.

In the case of the execute and command callbacks, once awaited, the result will be the option
values.

## Bash completion

Quoting the [Bash docs]:

> When word completion is attempted for an argument to a command for which a completion
> specification (a compspec) has been defined using the `complete` builtin (see Programmable
> Completion Builtins), the programmable completion facilities are invoked.

The parser does not use the completion facilities, because it relies on the command line string and
the completion index into that string, which can be retrieved from the following environment
variables (available when performing completion):

- `COMP_LINE` - the current command line
- `COMP_POINT` - the index of the current cursor position relative to the beginning of the current
  command

The way it does this is by inserting a placeholder into the command-line argument that is under the
completion index. This placeholder is then looked for at each iteration in the parsing loop to know
when to perform completion.

The result of completion is a list of words separated by line breaks (on Linux), and should be
printed on the terminal so that the `complete` builtin can perform the final completion step.

<Callout type="info">
  The parser ignores any errors thrown by callbacks during completion. If an error is thrown by a
  completion callback, the default completion message (an empty list) will be used instead.
</Callout>

### Completion algorithm

The completion algorithm implemented by the library is explained below. In what follows, _comp_ is
the word being completed, i.e., the command-line argument ending at the completion index (it may be
an empty string):

1. If _comp_ is expected to be an option name:
   - If _comp_ is a known option name, that name is returned; else
   - If there's no positional option, the available option names are filtered by the prefix _comp_,
     and then returned; else
   - _comp_ is treated as a parameter of the positional option; go to step 2
2. _comp_ is the parameter of a non-niladic option:
   - If the option has a [complete callback](options.mdx#complete-callback), it is called with
     _comp_ and its result is returned; else
   - If it is a boolean option, the words `'true'{:ts}` and `'false'{:ts}` are filtered by the prefix
     _comp_, and then returned; else
   - If the option has [enumerated values](options.mdx#enumeration), those values are converted to
     string, filtered by the prefix _comp_, and then returned; else
   - If it is a variadic array option, and the parameter was specified neither with a positional
     marker nor as an [inline parameters](#inline-parameters), the available option names are
     filtered by the prefix _comp_ and returned; else
   - No words are returned, and the default bash completion (if enabled with `-o`) is attempted.

During completion, help and version options are skipped, while others are processed as usual. This
means that a completion callback can inspect the values parsed before it, in order to make better
suggestions based on those values.

## Requirements checking

Generally, option requirements are evaluated after all arguments have been parsed. During this
analysis, an option's value is checked against any value required by other options, _except_ if the
option value is a promise (this may happen if the option was declared with an asynchronous
[parsing callback](#parsing-callbacks)). This is because the parser cannot await a promise's
resolution before returning from the parsing loop.

This check may also be performed in two more situations:

- before calling a function option's [execute callback](options.mdx#execute-callback), if the
  `break` attribute was set
- before calling a command option's [command callback](options.mdx#command-callback)

However, requirements are not checked when performing bash completion. This is due to the fact that
the completion builtin always expects a list of words as result. Hence, the library must suppress
any errors that occur during parsing and it does not make sense to verify requirements in that case.

## Name suggestions

During parsing, there are two situations in which the parser might suggest option names:

- when it expects an option name and the current argument is not a valid name (and there is no
  positional option)
- when it expects an option parameter and the current argument fails to be parsed, and the affected
  option is a variadic array option (but only if the argument was specified neither with a
  positional marker nor as an [inline parameter](#inline-parameters))

In these cases, the parser selects option names that are similar to the current argument using the
[Gestalt algorithm], and includes them in the error message.

## Miscellaneous

### Error messages

Error messages generated by the parsing procedure can be customized via the validator's
[error configuration](validator.mdx#error-configuration), which can be provided as an additional
parameter to the parser constructor.

### Inline parameters

Option parameters may be passed on the command-line using the syntax `<name>=<value>`. This syntax
is only valid for non-niladic options and cannot be used with the positional marker. As is the case
with normal parameters, the value may contain any number of equal signs, and even start with one
(e.g., `-opt==val` would be parsed as `'=val'{:ts}`).

[Bash docs]: https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html
[Gestalt algorithm]: https://www.wikiwand.com/en/Gestalt_pattern_matching

### Process title

The process title will be updated to reflect the current command being executed. This includes the
main script and any nested commands. For example, if the command-line is:

```sh
./path/to/myscript.js -flag0 cmd1 -flag1 cmd2 args...
```

The process title would be updated in the following way:

1. `node` - this the starting title, before any update
2. `node myscript.js` - the title at the beginning of the parsing loop
3. `node myscript.js cmd1` - the title at the start of the `cmd1` command
4. `node myscript.js cmd1 cmd2` - the title at the start of the `cmd2` command

The title will remain unchanged after the parser returns. Other option names are not used, because
they would pollute the output of process management utilities such as `ps`.
