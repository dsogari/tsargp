---
title: Validator - Library - Docs
---

import { Callout } from 'nextra/components';

# Validator

The `OptionValidator` class is an internal component that the parser uses to register and validate
option definitions. You should _not_ need to instantiate this class directly. Instead, use the
`validate` method on the parser instance.

## Option validation

The term _validation_ here means verifying the sanity of the options' definitions. It is intended
for use during development, _not_ in production where it would impose a needless performance penalty
on your application. The validations behave like assertions: they assert that your options will work
as expected when delivered to end-users.

To validate a set of option definitions, you must call the `validate` method on the parser instance.
The following sections describe the various kinds of validation performed by this method. Any option
definition that does not satisfy one of these restrictions will trigger an error with an explanatory
message that may include the option's key.

<Callout type="info">
  Validation is performed recursively for nested commands, skipping circular references when
  necessary.
</Callout>

### Names validation

Option names are subject to the restrictions listed below:

- **Option with no name** -
  If the option is not positional (i.e., it does not accept positional arguments), then it must
  contain at least one _non-empty_ name.
- **Invalid option name** -
  An option name must not contain whitespace or the equals sign `'='{:ts}`, since this character can
  be used as option-value separator on the command-line. Any other Unicode character is allowed.
- **Duplicate option name** -
  An option should not have duplicate names, and there cannot be two options with the same name.

<Callout type="info">
  In any of these restrictions, empty strings and `null{:ts}`s are ignored, while flags' [negation
  names] and the [positional marker] are included.
</Callout>

### Cluster letter validation

Cluster letters are subject to the restrictions listed below:

- **Duplicate cluster letter** -
  An option should not have duplicate cluster letters, and there cannot be two options with the
  same letter.
- **Invalid cluster letter** -
  A cluster letter must not contain whitespace. Any other Unicode character is allowed.

### Enums validation

Enumerated values are subject to the restrictions listed below:

- **Zero enum values** -
  There cannot be an option with zero enumerated values. The enumeration array should have
  _non-zero_ length.
- **Duplicate enum value** -
  There cannot be an option with duplicate enumerated values. The enumeration array should _not_
  contain duplicate elements.

### Value validation

Valued options may define a default value, while non-niladic options may define an example value. If
present, these attributes are subject to the same set of constraints as that of the command-line
arguments, which are listed below:

- **Enums constraint violation** -
  If the [enums] attribute is present, then default and example values must equal one of the
  enumerated values after being normalized. (The enumerated values themselves are not normalized.)
- **Regex constraint violation** -
  In a string-valued option, if the [regex] attribute is present, then default and example values
  must match the regular expression after being normalized.
- **Range constraint violation** -
  In a number-valued option, if the [range] attribute is present, then default and example values
  must be within this range after being normalized.
- **Limit constraint violation** -
  In an array-valued option, if the [limit] attribute is present, then default and example values
  must have a length that does not exceed the given limit after being normalized.

<Callout type="info">
  This does not apply to [default callbacks]. They are ignored during validation.
</Callout>

### Requirements validation

When an option declares requirements referencing other options, these requirements are subject to
the restrictions listed below:

- **Option requiring itself** -
  An option must not declare a requirement that references itself.
- **Unknown required option** -
  An option must not declare a requirement that references an _unknown_ option.
- **Invalid required option** -
  An option must not declare a requirement that references a _non-valued_ option.
- **Incompatible required value** -
  Since a requirement may be an object with values of any kind, the data type of these values must
  be validated at run-time. Thus, an option must not declare a requirement that references a valued
  option, if it requires a value that does _not_ conform to the data type expected by that option.
- **Constraint violationn** -
  If an option declares a requirement that includes a required value, then that value is subject to
  the same set of constraints as that of the command-line arguments, so it must satisfy the
  restrictions listed in [value validation].

<Callout type="info">
  This does not apply to [requirement callbacks]. They are ignored during validation.
</Callout>

### Positional validation

Options declared with the [positional] attribute are subject to the restrictions listed below:

- **Duplicate positional option** -
  Since positional arguments have no name, they must pertain to exactly one option. Hence, there
  cannot be _two_ options with the positional attribute in the same set of option definitions.
- **Empty positional marker** -
  If an option defines a positional marker, it cannot be the _empty_ string.

### Version validation

A version option is very simple and has only one restraint:

- **Empty version string** -
  A version option must not contain an _empty_ version string.

## Error configuration

Both the validation and the parsing methods may throw errors which can be customized with an
`ErrorConfig` object. This object has some optional properties, as described below.

### Error styles

The `styles` property specifies the styles of both error and help messages, and has the following
optional properties:

- `boolean` - the style of boolean values (defaults to `fg.yellow`)
- `string` - the style of string values (defaults to `fg.green`)
- `number` - the style of number values (defaults to `fg.yellow`)
- `regex` - the style of regular expressions (defaults to `fg.red`)
- `option` - the style of option names (defaults to `fg.brightMagenta`)
- `param` - the style of option parameters (defaults to `fg.brightBlack`)
- `url` - the style of URLs (defaults to `fg.brightBlack`)
- `text` - The style of general text (defaults to `tf.clear`)

<Callout type="default">
  You can also set these styles to the empty string, if you know that your user&apos;s terminal does
  not support control sequences.
</Callout>

### Error items

The `ErrorItem` enumeration lists the kinds of error messages that may be raised by the library:

- `parseError` -
  raised by the parser when an option parameter fails to be parsed
- `parseErrorWithSimilar` -
  raised by the parser when an option parameter fails to be parsed, and there are option name
  suggestions
- `unknownOption` -
  raised by the parser when an option name is not found
- `unknownOptionWithSimilar` -
  raised by the parser when an option name is not found, and there are option name suggestions
- `unsatisfiedRequirement` -
  raised by the parser when an option requirement is not satisfied
- `missingRequiredOption` -
  raised by the parser when an option that is always required was not specified
- `missingParameter` -
  raised by the parser when an option parameter is expected but was not specified
- `missingPackageJson` -
  raised by the parser when it fails to find a "package.json" file when resolving the version
- `disallowedInlineValue` -
  raised by the parser when either a niladic option or a positional marker is specified with an
  inline value
- `emptyPositionalMarker` -
  raised by the validator when a positional option has an empty positional marker
- `unnamedOption` -
  raised by the validator when a non-positional option has no name
- `invalidOptionName` -
  raised by the validator when an option has an invalid name
- `emptyVersionDefinition` -
  raised by the validator when a version option has an empty version string
- `invalidSelfRequirement` -
  raised by the validator when an option references itself in a requirement
- `unknownRequiredOption` -
  raised by the validator when an option references an unknown option in a requirement
- `invalidRequiredOption` -
  raised by the validator when an option references a non-valued option in a requirement
- `emptyEnumsDefinition` -
  raised by the validator when an option has a zero-length enumeration array
- `duplicateOptionName` -
  raised by the validator when an option has a duplicate name
- `duplicatePositionalOption` -
  raised by the validator when there are two or more positional options
- `duplicateStringEnum` -
  raised by the validator when a string enumeration constraint has duplicate values
- `duplicateNumberEnum` -
  raised by the validator when a number enumeration constraint has duplicate values
- `incompatibleRequiredValue` -
  raised by the validator when an option is required with a value of incompatible data type
- `stringEnumsConstraintViolation` -
  raised by both the parser and validator when a value fails to satisfy a string option's
  enumeration constraint
- `regexConstraintViolation` -
  raised by both the parser and validator when a value fails to satisfy a string option's regex
  constraint
- `numberEnumsConstraintViolation` -
  raised by both the parser and validator when a value fails to satisfy a number option's
  enumeration constraint
- `rangeConstraintViolation` -
  raised by both the parser and validator when a value fails to satisfy a number option's range
  constraint
- `limitConstraintViolation` -
  raised by both the parser and validator when a value fails to satisfy an array option's limit
  constraint
- `deprecatedOption` -
  warning saved by the parser when a deprecated option is specified on the command-line
- `unsatisfiedCondRequirement` -
  raised by the parser when a conditional option requirement is not satisfied
- `duplicateClusterLetter` -
  raised by the validator when an option has a duplicate cluster letter
- `invalidClusterOption` -
  raised by the parser when either a variadic array option or a command option is specified in the
  middle of a cluster argument
- `invalidClusterLetter` -
  raised by the validator when an option has an invalid cluster letter

### Error phrases

The `phrases` property specifies the phrases to be used for each kind of error message:

- `parseError` - `'Did you mean to specify an option name instead of %o?'{:ts}`
- `parseErrorWithSimilar` - `'Did you mean to specify an option name instead of %o1? Similar names are %o2.'{:ts}`
- `unknownOption` - `'Unknown option %o.'{:ts}`
- `unknownOptionWithSimilar` - `'Unknown option %o1. Similar names are %o2.'{:ts}`
- `unsatisfiedRequirement` - `'Option %o requires %t.'{:ts}`
- `missingRequiredOption` - `'Option %o is required.'{:ts}`
- `missingParameter` - `'Missing parameter to %o.'{:ts}`
- `missingPackageJson` - `'Could not find a "package.json" file.'{:ts}`
- `disallowedInlineValue` - `'Option %o does not accept inline values.'{:ts}`
- `emptyPositionalMarker` - `'Option %o contains empty positional marker.'{:ts}`
- `unnamedOption` - `'Non-positional option %o has no name.'{:ts}`
- `invalidOptionName` - `'Option %o has invalid name %s.'{:ts}`
- `emptyVersionDefinition` - `'Option %o contains empty version.'{:ts}`
- `invalidSelfRequirement` - `'Option %o requires itself.'{:ts}`
- `unknownRequiredOption` - `'Unknown option %o in requirement.'{:ts}`
- `invalidRequiredOption` - `'Non-valued option %o in requirement.'{:ts}`
- `emptyEnumsDefinition` - `'Option %o has zero enum values.'{:ts}`
- `duplicateOptionName` - `'Option %o has duplicate name %s.'{:ts}`
- `duplicatePositionalOption` - `'Duplicate positional option %o1: previous was %o2.'{:ts}`
- `duplicateStringEnum` - `'Option %o has duplicate enum %s.'{:ts}`
- `duplicateNumberEnum` - `'Option %o has duplicate enum %n.'{:ts}`
- `incompatibleRequiredValue` - `'Option %o has incompatible value %p. Should be of type %s.'{:ts}`
- `stringEnumsConstraintViolation` - `'Invalid parameter to %o: %s1. Possible values are %s2.'{:ts}`
- `regexConstraintViolation` - `'Invalid parameter to %o: %s. Value must match the regex %r.'{:ts}`
- `numberEnumsConstraintViolation` - `'Invalid parameter to %o: %n1. Possible values are %n2.'{:ts}`
- `rangeConstraintViolation` - `'Invalid parameter to %o: %n1. Value must be in the range %n2.'{:ts}`
- `limitConstraintViolation` - `'Option %o has too many values (%n1). Should have at most %n2.'{:ts}`
- `deprecatedOption` - `'Option %o is deprecated and may be removed in future releases.'{:ts}`
- `unsatisfiedCondRequirement` - `'Option %o is required if %t.'{:ts}`
- `duplicateClusterLetter` - `'Option %o has duplicate cluster letter %s.'{:ts}`
- `invalidClusterOption` - `'Option letter %o must be the last in a cluster.'{:ts}`
- `invalidClusterLetter` - `'Option %o has invalid cluster letter %s.'{:ts}`

These phrases will be formatted according to [text formatting] rules.

### Error specifiers

Error phrases may have specifiers that are replaced with a value:

- `b` - a boolean value
- `s` - a string value (or values)
- `n` - a number value (or values)
- `r` - a regular expression
- `o` - an option name
- `p` - a generic value enclosed in angle brackets (like the [parameter column])
- `u` - a URL
- `t` - a previously formatted string that is enhanced with additional details

Specifiers may end with a single digit that represents a specific value in the error message. The
following table lists the available specifiers for each kind of error message, along with a
description of the corresponding value.

| Error                          | Specifiers                                                                      |
| ------------------------------ | ------------------------------------------------------------------------------- |
| parseError                     | `%o` = the unknown option name                                                  |
| parseErrorWithSimilar          | `%o1`= the unknown option name; `%o2` = similar option names                    |
| unknownOption                  | `%o` = the unknown option name                                                  |
| unknownOptionWithSimilar       | `%o1` = the unknown option name; `%o2` = similar option names                   |
| unsatisfiedRequirement         | `%o` = the specified option name; `%t` = the option's requirements              |
| missingRequiredOption          | `%o` = the option's preferred name                                              |
| missingParameter               | `%o` = the specified option name                                                |
| missingPackageJson             |                                                                                 |
| disallowedInlineValue          | `%o` = the specified option name or positional marker                           |
| emptyPositionalMarker          | `%o` = the option key                                                           |
| unnamedOption                  | `%o` = the option key                                                           |
| invalidOptionName              | `%o` = the option key; `%s` = the invalid name                                  |
| emptyVersionDefinition         | `%o` = the option key                                                           |
| invalidSelfRequirement         | `%o` = the option key                                                           |
| unknownRequiredOption          | `%o` = the required option key                                                  |
| invalidRequiredOption          | `%o` = the required option key                                                  |
| emptyEnumsDefinition           | `%o` = the option key                                                           |
| duplicateOptionName            | `%o` = the option key; `%s` = the duplicate name                                |
| duplicatePositionalOption      | `%o` = the option key                                                           |
| duplicateStringEnum            | `%o` = the option key; `%s` = the duplicate enum value                          |
| duplicateNumberEnum            | `%o` = the option key; `%n` = the duplicate enum value                          |
| incompatibleRequiredValue      | `%o` = the option key; `%p` = the incompatible value; `%s` = the expected type  |
| stringEnumsConstraintViolation | `%o` = the option key or name; `%s1` = the specified value; `%s2` = the enums   |
| regexConstraintViolation       | `%o` = the option key or name; `%s` = the specified value; `%r` = the regex     |
| numberEnumsConstraintViolation | `%o` = the option key or name; `%n1` = the specified value; `%n2` = the enums   |
| rangeConstraintViolation       | `%o` = the option key or name; `%n1` = the specified value; `%n2` = the range   |
| limitConstraintViolation       | `%o` = the option key or name; `%n1` = the value count; `%n2` = the count limit |
| deprecatedOption               | `%o` = the specified option name                                                |
| unsatisfiedCondRequirement     | `%o` = the specified option name; `%t` = the option's requirements              |
| duplicateClusterLetter         | `%o` = the option key; `%s` = the duplicate letter                              |
| invalidClusterOption           | `%o` = the specified cluster letter                                             |
| invalidClusterLetter           | `%o` = the option key; `%s` = the invalid letter                                |

[value validation]: #value-validation
[negation names]: options#negation-names
[positional marker]: options#positional--marker
[enums]: options#enumeration
[regex]: options#regular-expression
[range]: options#numeric-range
[limit]: options#count-limit
[default callbacks]: options#default-value--callback
[requirement callbacks]: options#forward-requirements
[positional]: options#positional--marker
[text formatting]: styles#text-splitting
[parameter column]: formatter#parameter-column
