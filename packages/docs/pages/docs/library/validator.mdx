---
title: Validator - Library - Docs
---

import { Callout } from 'nextra/components';

# Validator

The `OptionValidator` class is an internal component that the parser uses to register and validate
option definitions. You should _not_ need to instantiate this class directly. Instead, use the
`validate` method on the parser instance.

## Option validation

The term _validation_ here means verifying the sanity of the options' definitions. It is intended
for use during _development_, not in production where it would impose a needless performance penalty
on your application. The validations behave like assertions: they assert that your program will work
as expected when delivered to end-users.

To validate a set of option definitions, you must call the `validate` method on the parser instance.
This method accepts a `ValidationFlags` argument with the following optional properties:

- `detectNamingInconsistencies` - whether the validation procedure should try to detect naming
  inconsistencies

It returns a `ValidationResult` object with the following optional properties:

- `warning` - A list of warning messages that represent not-so-dangerous issues encountered in the
  option definitions. You may want to print this to see if they are important to your application.

The following sections describe the various kinds of validation performed by this method. Unless
otherwise noted, any option definition that does not satisfy one of these restrictions will raise an
error with an explanatory message that may include the option's key.

<Callout type="info">
  Validation is performed recursively for nested commands, skipping circular references when
  necessary.
</Callout>

### Names validation

Option names are subject to the restrictions listed below:

- **Option with no name** -
  If the option is not positional (i.e., it does not accept positional arguments), then it must
  contain at least one _non-empty_ name.
- **Invalid option name** -
  An option name must not contain whitespace or the equals sign `'='{:ts}`, since this character can
  be used as option-value separator on the command-line. Any other Unicode character is allowed.
- **Duplicate option name** -
  An option should not have duplicate names, and there cannot be two options with the same name.

<Callout type="info">
  In any of these restrictions, empty strings and `null{:ts}`s are ignored, while flags' [negation
  names] and the [positional marker] are included.
</Callout>

#### Naming inconsistencies

In addition to the above, the validator may generate warnings if it detects naming inconsistencies,
such as:

- **Too similar names** -
  When an option name is too similar to other names (e.g., if it differs by a single character in a
  five-character name), this may be a development mistake at best, or at worst it can become a
  source of headaches for end-users. Hence, the validator tries to find names that closely match a
  given name using the same algorithm used by the parser in [name suggestions], just a little
  stricter.
- **Mixed naming convention** -
  When a [name slot] contains names with different naming conventions (e.g., all-uppercase vs
  all-lowercase, or single-dash vs double-dash), this may be a sign of code review negligence at
  best, or at worst it can make it hard for end-users to reason about your application. Thus, the
  validator tries to find names within a slot that contain mixed naming patterns.

### Cluster letter validation

Cluster letters are subject to the restrictions listed below:

- **Duplicate cluster letter** -
  An option should not have duplicate cluster letters, and there cannot be two options with the
  same letter.
- **Invalid cluster letter** -
  A cluster letter must not contain whitespace. Any other Unicode character is allowed.

### Constraints validation

Constraint definitions are subject to the restrictions listed below:

- **Zero enum values** -
  In number-valued and string-valued options, if the [enums] attribute is present, it must _not_ be
  empty. It should have non-zero length.
- **Duplicate enum value** -
  In number-valued and string-valued options, if the [enums] attribute is present, it must _not_
  contain duplicate elements.
- **Invalid numeric range** -
  In a number-valued option, if the [range] attribute is present, then its minimum value should be
  strictly less than the maximum.

### Value validation

Valued options may define a default value, while non-niladic options may define an example value. If
present, these attributes are subject to the same set of constraints as that of the command-line
arguments, which are listed below:

- **Enums constraint violation** -
  If the [enums] attribute is present, then default and example values must equal one of the
  enumerated values after being normalized. (The enumerated values themselves are not normalized.)
- **Regex constraint violation** -
  In a string-valued option, if the [regex] attribute is present, then default and example values
  must match the regular expression after being normalized.
- **Range constraint violation** -
  In a number-valued option, if the [range] attribute is present, then default and example values
  must be within this range after being normalized.
- **Limit constraint violation** -
  In an array-valued option, if the [limit] attribute is present, then default and example values
  must have a length that does not exceed the given limit after being normalized.

<Callout type="info">
  This does not apply to [default callbacks]. They are ignored during validation.
</Callout>

### Requirements validation

When an option declares requirements referencing other options, these requirements are subject to
the restrictions listed below:

- **Option requiring itself** -
  An option must not declare a requirement that references itself.
- **Unknown required option** -
  An option must not declare a requirement that references an _unknown_ option.
- **Invalid required option** -
  An option must not declare a requirement that references either a non-valued option (help and
  version) or an option with unknown values (function and command) in a requirement.
- **Invalid required value** -
  An option must not declare a requirement that references another option that is either [always
  required] or has a [default value], if the required value is nullish (`null{:ts}` or
  `undefined{:ts}`).
- **Incompatible required value** -
  Since a requirement may be an object with values of any kind, the data type of these values must
  be validated at run-time. Thus, an option must not declare a requirement that references a valued
  option, if it requires a value that does _not_ conform to the data type expected by that option.
- **Constraint violationn** -
  If an option declares a requirement that includes a required value, then that value is subject to
  the same set of constraints as that of the command-line arguments, so it must satisfy the
  restrictions listed in [value validation].

<Callout type="info">
  This does not apply to [requirement callbacks]. They are ignored during validation.
</Callout>

### Positional validation

Options declared with the [positional] attribute are subject to the restrictions listed below:

- **Duplicate positional option** -
  Since positional arguments have no name, they must pertain to exactly one option. Hence, there
  cannot be _two_ options with the positional attribute in the same set of option definitions.
- **Empty positional marker** -
  If an option defines a positional marker, it cannot be the _empty_ string.

### Version validation

A version option is very simple and has only one restraint:

- **Empty version string** -
  A version option must not contain an _empty_ version string.

## Validator configuration

Both the validation and parsing methods may throw errors which can be customized with a
`ValidatorConfig` object. This object has some optional properties, as described below.

### Error styles

The `styles` property specifies the styles of both error and help messages, and has the following
optional properties:

- `boolean` - the style of boolean values (defaults to `fg.yellow`)
- `string` - the style of string values (defaults to `fg.green`)
- `number` - the style of number values (defaults to `fg.yellow`)
- `regex` - the style of regular expressions (defaults to `fg.red`)
- `option` - the style of option names (defaults to `fg.brightMagenta`)
- `value` - the style of generic (or unknown) values (defaults to `fg.brightBlack`)
- `url` - the style of URLs (defaults to `fg.brightBlack`)
- `text` - The style of general text (defaults to `tf.clear`)

<Callout type="default">
  You can also set these styles to the empty string, if you know that your user&apos;s terminal does
  not support control sequences.
</Callout>

### Error items

The `ErrorItem` enumeration lists the kinds of error messages that may be raised by the library:

- `parseError` -
  raised by the parser when an option parameter fails to be parsed, with possible option name
  suggestions
- `unknownOption` -
  raised by the parser when an option name is not found, with possible option name suggestions
- `unsatisfiedRequirement` -
  raised by the parser when an option requirement is not satisfied
- `missingRequiredOption` -
  raised by the parser when an option that is always required was not specified
- `missingParameter` -
  raised by the parser when an option parameter is expected but was not specified
- `missingPackageJson` -
  raised by the parser when it fails to find a "package.json" file when resolving the version
- `disallowedInlineValue` -
  raised by the parser when either a niladic option or a positional marker is specified with an
  inline value
- `emptyPositionalMarker` -
  raised by the validator when a positional option has an empty positional marker
- `unnamedOption` -
  raised by the validator when a non-positional option has no name
- `invalidOptionName` -
  raised by the validator when an option has an invalid name
- `emptyVersionDefinition` -
  raised by the validator when a version option has an empty version string
- `invalidSelfRequirement` -
  raised by the validator when an option references itself in a requirement
- `unknownRequiredOption` -
  raised by the validator when an option references an unknown option in a requirement
- `invalidRequiredOption` -
  raised by the validator when an option references either a non-valued option or an option with
  unknown values in a requirement
- `invalidRequiredValue` -
  raised by the validator when an option uses a nullish value in a requirement that references an
  option that is either always required or has a default value
- `incompatibleRequiredValue` -
  raised by the validator when an option is required with a value of incompatible data type
- `emptyEnumsDefinition` -
  raised by the validator when an option has a zero-length enumeration array
- `duplicateOptionName` -
  raised by the validator when an option has a duplicate name
- `duplicatePositionalOption` -
  raised by the validator when there are two or more positional options
- `duplicateEnumValue` -
  raised by the validator when a string or number enumeration constraint has duplicate values
- `enumsConstraintViolation` -
  raised by both the parser and validator when a value fails to satisfy either a string or a number
  enumeration constraint
- `regexConstraintViolation` -
  raised by both the parser and validator when a value fails to satisfy a string regex constraint
- `rangeConstraintViolation` -
  raised by both the parser and validator when a value fails to satisfy a number range constraint
- `limitConstraintViolation` -
  raised by both the parser and validator when a value fails to satisfy an array limit constraint
- `deprecatedOption` -
  warning produced by the parser when a deprecated option is specified on the command-line
- `unsatisfiedCondRequirement` -
  raised by the parser when a conditional option requirement is not satisfied
- `duplicateClusterLetter` -
  raised by the validator when an option has a duplicate cluster letter
- `invalidClusterOption` -
  raised by the parser when either a variadic array option or a command option is specified in the
  middle of a cluster argument
- `invalidClusterLetter` -
  raised by the validator when an option has an invalid cluster letter
- `tooSimilarOptionNames` -
  warning produced by the validator when an option name is too similar to other names
- `mixedNamingConvention` -
  warning produced by the validator when a name slot contains names with different naming
  conventions
- `invalidNumericRange` -
  raised by the validator when an option has an invalid numeric range

### Error phrases

The `phrases` property specifies the phrases to be used for each kind of error message. It has the
following optional properties, which are the enumerators from `ErrorItem`:

- `parseError` - `'Did you mean to specify an option name instead of (%o|%o1)?(| Similar names are [%o2].)'{:ts}`
- `unknownOption` - `'Unknown option (%o|%o1).(| Similar names are [%o2].)'{:ts}`
- `unsatisfiedRequirement` - `'Option %o requires %p.'{:ts}`
- `missingRequiredOption` - `'Option %o is required.'{:ts}`
- `missingParameter` - `'Missing parameter to %o.'{:ts}`
- `missingPackageJson` - `'Could not find a "package.json" file.'{:ts}`
- `disallowedInlineValue` - `'(Option|Positional marker) %o does not accept inline values.'{:ts}`
- `emptyPositionalMarker` - `'Option %o contains empty positional marker.'{:ts}`
- `unnamedOption` - `'Non-positional option %o has no name.'{:ts}`
- `invalidOptionName` - `'Option %o has invalid name %s.'{:ts}`
- `emptyVersionDefinition` - `'Option %o contains empty version.'{:ts}`
- `invalidSelfRequirement` - `'Option %o requires itself.'{:ts}`
- `unknownRequiredOption` - `'Unknown option %o in requirement.'{:ts}`
- `invalidRequiredOption` - `'Invalid option %o in requirement.'{:ts}`
- `invalidRequiredValue`- `'Invalid required value for option %o. Option is always required or has a default value.'{:ts}`
- `incompatibleRequiredValue` - `'Incompatible required value %v for option %o. Should be of type %s.'{:ts}`
- `emptyEnumsDefinition` - `'Option %o has zero enum values.'{:ts}`
- `duplicateOptionName` - `'Option %o has duplicate name %s.'{:ts}`
- `duplicatePositionalOption` - `'Duplicate positional option %o1: previous was %o2.'{:ts}`
- `duplicateEnumValue` - `'Option %o has duplicate enum (%s|%n).'{:ts}`
- `enumsConstraintViolation` - `'Invalid parameter to %o: (%s1|%n1). Possible values are {(%s2|%n2)}.'{:ts}`
- `regexConstraintViolation` - `'Invalid parameter to %o: %s. Value must match the regex %r.'{:ts}`
- `rangeConstraintViolation` - `'Invalid parameter to %o: %n1. Value must be in the range [%n2].'{:ts}`
- `limitConstraintViolation` - `'Option %o has too many values (%n1). Should have at most %n2.'{:ts}`
- `deprecatedOption` - `'Option %o is deprecated and may be removed in future releases.'{:ts}`
- `unsatisfiedCondRequirement` - `'Option %o is required if %p.'{:ts}`
- `duplicateClusterLetter` - `'Option %o has duplicate cluster letter %s.'{:ts}`
- `invalidClusterOption` - `'Option letter %o must be the last in a cluster.'{:ts}`
- `invalidClusterLetter` - `'Option %o has invalid cluster letter %s.'{:ts}`
- `tooSimilarOptionNames` - `'%o: Option name %s1 has too similar names %s2.'{:ts}`
- `mixedNamingConvention` - `'%o: Name slot %n has mixed naming conventions [%s].'{:ts}`
- `invalidNumericRange` - `'Option %o has invalid numeric range [%n].'{:ts}`

These phrases will be formatted according to [text formatting] rules.

#### Format specifiers

Error phrases may have [format specifiers] prefixed with a percent sign `%`, which get replaced with
a value. The following table lists the available specifiers for each kind of error message, along
with a description of the corresponding value:

| Error                      | Specifiers                                                                                  |
| -------------------------- | ------------------------------------------------------------------------------------------- |
| parseError                 | `%o`/`%o1` = the unknown option name; `%o2` = similar option names                          |
| unknownOption              | `%o`/`%o1` = the unknown option name; `%o2` = similar option names                          |
| unsatisfiedRequirement     | `%o` = the specified option name; `%p` = the option's requirements                          |
| missingRequiredOption      | `%o` = the option's preferred name                                                          |
| missingParameter           | `%o` = the specified option name                                                            |
| missingPackageJson         |                                                                                             |
| disallowedInlineValue      | `%o` = the specified option name or positional marker                                       |
| emptyPositionalMarker      | `%o` = the option's key                                                                     |
| unnamedOption              | `%o` = the option's key                                                                     |
| invalidOptionName          | `%o` = the option's key; `%s` = the invalid name                                            |
| emptyVersionDefinition     | `%o` = the option's key                                                                     |
| invalidSelfRequirement     | `%o` = the option's key                                                                     |
| unknownRequiredOption      | `%o` = the required option's key                                                            |
| invalidRequiredOption      | `%o` = the required option's key                                                            |
| invalidRequiredValue       | `%o` = the required option's key                                                            |
| incompatibleRequiredValue  | `%o` = the required option's key; `%v` = the incompatible value; `%s` = the expected type   |
| emptyEnumsDefinition       | `%o` = the option's key                                                                     |
| duplicateOptionName        | `%o` = the option's key; `%s` = the duplicate name                                          |
| duplicatePositionalOption  | `%o1` = the duplicate option's key; `%o2` = the previous option's key                       |
| duplicateEnumValue         | `%o` = the option's key; `%s`/`%n` = the duplicate enum value                               |
| enumsConstraintViolation   | `%o` = the option's key or name; `%s1`/`%n1` = the specified value; `%s2`/`%n2` = the enums |
| regexConstraintViolation   | `%o` = the option's key or name; `%s` = the specified value; `%r` = the regex               |
| rangeConstraintViolation   | `%o` = the option's key or name; `%n1` = the specified value; `%n2` = the range             |
| limitConstraintViolation   | `%o` = the option's key or name; `%n1` = the value count; `%n2` = the count limit           |
| deprecatedOption           | `%o` = the specified option name                                                            |
| unsatisfiedCondRequirement | `%o` = the specified option name; `%p` = the option's requirements                          |
| duplicateClusterLetter     | `%o` = the option's key; `%s` = the duplicate letter                                        |
| invalidClusterOption       | `%o` = the specified cluster letter                                                         |
| invalidClusterLetter       | `%o` = the option's key; `%s` = the invalid letter                                          |
| tooSimilarOptionNames      | `%o` = the command prefix[^1]; `%s1` = the option name; `%s2` = the similar names           |
| mixedNamingConvention      | `%o` = the command prefix[^1]; `%n` = the slot index; `%s` = the naming conventions         |

### Connective words

The `connectives` property specifies the connective words to be used in the formatting of option
requirements, in both error and help messages. It has the following optional properties, which are
the enumerators from `ConnectiveWords`:

- `and` - the word used to connect two logical expressions in conjunction
- `or` - the word to connect two logical expressions in disjunction
- `not` - the word to connect a logical expression in negation
- `equals` - the word to connect two expressions in equality comparison
- `notEquals` - the word to connect two expressions in non-equality comparison

[value validation]: #value-validation
[negation names]: options#negation-names
[positional marker]: options#positional--marker
[enums]: options#enumeration
[regex]: options#regular-expression
[range]: options#numeric-range
[limit]: options#count-limit
[default callbacks]: options#default-value--callback
[requirement callbacks]: options#forward-requirements
[positional]: options#positional--marker
[text formatting]: styles#text-splitting
[name suggestions]: parser#name-suggestions
[name slot]: formatter#names-column
[nested command]: options#command-option
[format specifiers]: styles#format-specifiers
[always required]: options#always-required
[default value]: options#default-value--callback

[^1]:
    the command prefix is a series of option keys interspersed with periods, denoting the current
    [nested command] in a hierarquical option definition. It starts as the empty string and is
    appended with the command option's key whenever a nested command is encountered. This prefix
    also appears in other validation error messages, embedded in the value that replaces the `%o`
    specifier. Here's an example: `cmd1.cmd2.flag`.
