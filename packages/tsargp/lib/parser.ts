//--------------------------------------------------------------------------------------------------
// Imports
//--------------------------------------------------------------------------------------------------
import type {
  Options,
  OptionValues,
  OpaqueOptionValues,
  Requires,
  RequiresEntry,
  CompleteCallback,
  ResolveCallback,
  OpaqueOption,
  OpaqueOptions,
} from './options';
import type { OptionInfo, ConcreteConfig, ValidatorConfig } from './validator';

import { ErrorItem } from './enums';
import { HelpFormatter } from './formatter';
import {
  RequiresAll,
  RequiresNot,
  RequiresOne,
  isArray,
  isVariadic,
  isNiladic,
  isSpecial,
  isString,
  isBoolean,
  isUnknown,
} from './options';
import {
  ErrorMessage,
  WarnMessage,
  VersionMessage,
  CompletionMessage,
  TerminalString,
  FormatConfig,
} from './styles';
import { OptionValidator, defaultConfig } from './validator';
import { format } from './styles';
import { checkRequiredArray, findSimilarNames, getArgs, isTrue } from './utils';

//--------------------------------------------------------------------------------------------------
// Public types
//--------------------------------------------------------------------------------------------------
/**
 * The parse configuration.
 */
export type ParseConfig = {
  /**
   * The program name.
   */
  readonly progName?: string;
  /**
   * The completion index of a raw command line.
   */
  readonly compIndex?: number;
  /**
   * True if the first argument is expected to be an option cluster (i.e., short-option style).
   */
  readonly shortStyle?: true;
};

/**
 * The parse result.
 */
export type ParseResult = {
  /**
   * The warnings generated by the parser, if any.
   */
  readonly warning?: WarnMessage;
};

/**
 * The command line or command-line arguments.
 */
export type CommandLine = string | Array<string>;

//--------------------------------------------------------------------------------------------------
// Classes
//--------------------------------------------------------------------------------------------------
/**
 * Implements parsing of command-line arguments into option values.
 * @template T The type of the option definitions
 */
export class ArgumentParser<T extends Options = Options> {
  private readonly validator: OptionValidator;

  /**
   * Creates an argument parser based on a set of option definitions.
   * @param options The option definitions
   * @param config The validator configuration
   */
  constructor(options: T, config: ValidatorConfig = {}) {
    const concreteConfig: ConcreteConfig = {
      styles: Object.assign({}, defaultConfig.styles, config.styles),
      phrases: Object.assign({}, defaultConfig.phrases, config.phrases),
    };
    this.validator = new OptionValidator(options, concreteConfig);
  }

  /**
   * Validates the option definitions. This should only be called during development and in unit
   * tests, but should be skipped in production.
   * @returns A list of validation warnings
   */
  validate(): WarnMessage {
    return this.validator.validate();
  }

  /**
   * Convenience method to parse command-line arguments into option values.
   * @param command The raw command line or command-line arguments
   * @param config The parse configuration
   * @returns The options' values
   */
  async parse(command?: CommandLine, config?: ParseConfig): Promise<OptionValues<T>> {
    const values = {} as OptionValues<T>;
    await this.parseInto(values, command, config);
    return values;
  }

  /**
   * Parses command-line arguments into option values.
   * @param values The options' values to parse into
   * @param command The raw command line or command-line arguments
   * @param config The parse configuration
   * @returns The parse result
   */
  async parseInto(
    values: OptionValues<T>,
    command?: CommandLine,
    config?: ParseConfig,
  ): Promise<ParseResult> {
    return doParse(this.validator, values, command, config);
  }
}

//--------------------------------------------------------------------------------------------------
// Functions
//--------------------------------------------------------------------------------------------------
/**
 * Parses the command-line arguments.
 * @param validator The option validator
 * @param values The option values
 * @param command The raw command line or command-line arguments
 * @param config The parse configuration
 * @returns The parse result
 */
async function doParse(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  command = process?.env['COMP_LINE'] ?? process?.argv.slice(2) ?? [],
  config: ParseConfig = { compIndex: Number(process?.env['COMP_POINT']) },
): Promise<ParseResult> {
  let args, progName;
  if (typeof command === 'string') {
    [progName, ...args] = getArgs(command, config.compIndex);
  } else {
    [progName, args] = [config.progName, command];
    if (progName === undefined) {
      progName = process?.argv[1].split(/[\\/]/).at(-1);
    }
  }
  const completing = (config.compIndex ?? -1) >= 0;
  if (!completing && progName && process?.title) {
    process.title += ' ' + progName;
  }
  if (config.shortStyle) {
    parseCluster(validator, args);
  }
  initValues(validator.options, values);
  const specifiedKeys = new Set<string>();
  const warning = new WarnMessage();
  await parseArgs(validator, values, args, specifiedKeys, completing, warning, progName);
  await checkRequired(validator, values, specifiedKeys); // assert(!completing);
  return warning.length ? { warning } : {};
}

/**
 * Initializes the option values.
 * @param options The option definitions
 * @param values The option values
 */
function initValues(options: OpaqueOptions, values: OpaqueOptionValues) {
  for (const key in options) {
    if (!(key in values) && !isSpecial(options[key])) {
      values[key] = undefined;
    }
  }
}

/**
 * Parses the first argument which is expected to be an option cluster.
 * @param validator The option validator
 * @param args The command-line arguments
 */
function parseCluster(validator: OptionValidator, args: Array<string>) {
  const cluster = args.shift();
  if (!cluster) {
    return;
  }
  for (let j = 0, i = 0; j < cluster.length; ++j) {
    const letter = cluster[j];
    if (letter === '-' && j == 0) {
      continue; // skip the first dash in the cluster
    }
    if (letter === '\0') {
      throw new CompletionMessage();
    }
    const key = validator.letters.get(letter);
    if (!key) {
      throw validator.error(ErrorItem.unknownOption, { o: letter }, { alt: 0 });
    }
    const option = validator.options[key];
    if (j < cluster.length - 1 && (option.type === 'command' || isVariadic(option))) {
      throw validator.error(ErrorItem.invalidClusterOption, { o: letter });
    }
    const name = option.names?.find((name) => name);
    if (!name) {
      continue; // skip options with no names
    }
    args.splice(i, 0, name);
    i += isNiladic(option) ? 1 : 2;
  }
}

/**
 * Reads the value of an environment variable.
 * @param validator The option validator
 * @param values The options' values to parse into
 * @param info The option information
 * @returns True if the environment variable was found
 */
async function readEnvVar(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  info: OptionInfo,
): Promise<boolean> {
  const { key, option, name } = info;
  const value = process?.env[name];
  if (value !== undefined) {
    if (option.type === 'flag') {
      values[key] = isTrue(value);
    } else {
      if (isArray(option)) {
        resetValue(values, key, option);
      }
      await parseParam(validator, values, info, value, false);
    }
    return true;
  }
  return false;
}

/**
 * Parses the command-line arguments.
 * @param validator The option validator
 * @param values The option values
 * @param args The command-line arguments
 * @param specifiedKeys The set of specified keys
 * @param completing True if performing completion
 * @param warning The warnings accumulated so far
 * @param progName The program name, if any
 * @returns A promise that must be awaited before continuing
 */
async function parseArgs(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  args: ReadonlyArray<string>,
  specifiedKeys: Set<string>,
  completing: boolean,
  warning: WarnMessage,
  progName?: string,
): Promise<void> {
  /** @ignore */
  function addKey(info: OptionInfo) {
    const { key, name, option } = info;
    if (!specifiedKeys.has(key)) {
      if (option.deprecated) {
        warning.push(validator.format(ErrorItem.deprecatedOption, { o: name }));
      }
      specifiedKeys.add(key);
    }
    if (isArray(option)) {
      resetValue(values, key, option);
      variadic = !option.separator;
    } else {
      variadic = false;
    }
  }
  let info: OptionInfo | undefined;
  let marker = false;
  let variadic = false;
  let suggestNames = false;
  for (let i = 0; i < args.length; ++i) {
    const [arg, comp] = args[i].split('\0', 2);
    const isComp = comp !== undefined;
    const isLast = i + 1 === args.length;
    let param = arg;
    if (!info || (variadic && !marker)) {
      const [name, value] = arg.split(/=(.*)/, 2);
      const key = validator.names.get(name);
      const hasValue = value !== undefined;
      if (key) {
        if (isComp && !hasValue) {
          throw new CompletionMessage(name);
        }
        const option = validator.options[key];
        const niladic = isNiladic(option);
        const isMarker = name === validator.positional?.marker;
        if (niladic || isMarker) {
          if (isComp) {
            throw new CompletionMessage();
          }
          if (!completing && hasValue) {
            const alt = isMarker ? 1 : 0;
            throw validator.error(ErrorItem.disallowedInlineValue, { o: name }, { alt });
          }
        }
        info = isMarker ? validator.positional : { key, name, option };
        addKey(info);
        if (isLast && !hasValue && !niladic && !variadic) {
          throw validator.error(ErrorItem.missingParameter, { o: info.name });
        }
        if (niladic) {
          const [breakLoop, skip] = await handleNiladic(
            validator,
            values,
            specifiedKeys,
            completing,
            args.slice(i + 1),
            info,
            warning,
            progName,
          );
          i += skip;
          if (breakLoop) {
            return;
          }
          info = undefined;
          continue;
        }
        if (isMarker || !hasValue) {
          marker = isMarker;
          suggestNames = !marker && variadic;
          continue;
        }
        suggestNames = false;
        variadic = false; // treat inline value as single parameter
        param = value;
      } else if (!info) {
        if (!validator.positional) {
          if (isComp) {
            handleNameCompletion(validator, arg);
          }
          handleUnknown(validator, name);
        }
        info = validator.positional;
        addKey(info);
        suggestNames = true;
      }
    }
    if (isComp) {
      const { option } = info;
      if (option.complete) {
        return handleComplete(values, option.complete, args.slice(i + 1), param);
      }
      handleCompletion(option, param);
      if (suggestNames) {
        handleNameCompletion(validator, param);
      }
      throw new CompletionMessage();
    }
    await parseParam(validator, values, info, param, completing, suggestNames);
    if (!variadic && !marker) {
      info = undefined;
    }
  }
}

/**
 * Resolve a package version using a module-resolve function.
 * @param validator The option validator
 * @param resolve The resolve callback
 */
async function resolveVersion(
  validator: OptionValidator,
  resolve: ResolveCallback,
): Promise<never> {
  const { promises } = await import('fs');
  for (
    let path = './package.json', lastResolved = '', resolved = resolve(path);
    resolved != lastResolved;
    path = '../' + path, lastResolved = resolved, resolved = resolve(path)
  ) {
    try {
      const jsonData = await promises.readFile(new URL(resolved));
      const { version } = JSON.parse(jsonData.toString());
      throw new VersionMessage(version);
    } catch (err) {
      if ((err as ErrnoException).code != 'ENOENT') {
        throw err;
      }
    }
  }
  throw validator.error(ErrorItem.missingPackageJson);
}

/**
 * Handles the completion of an option with a parameter.
 * @param option The option definition
 * @param param The option parameter
 */
function handleCompletion(option: OpaqueOption, param?: string) {
  let words =
    option.type === 'boolean'
      ? ['true', 'false']
      : option.enums
        ? option.enums.map((val) => `${val}`)
        : [];
  if (words.length && param) {
    words = words.filter((word) => word.startsWith(param));
  }
  if (words.length) {
    throw new CompletionMessage(...words);
  }
}

/**
 * Handles an unknown option.
 * @param validator The option validator
 * @param name The unknown option name
 * @param err The previous error message, if any
 */
function handleUnknown(validator: OptionValidator, name: string, err?: ErrorMessage): never {
  const similar = findSimilarNames(name, [...validator.names.keys()], 0.6);
  const [args, alt] = similar.length ? [{ o1: name, o2: similar }, 1] : [{ o: name }, 0];
  const config: FormatConfig = { alt, sep: ',' };
  if (err) {
    err.msg.push(validator.format(ErrorItem.parseError, args, config));
  } else {
    err = validator.error(ErrorItem.unknownOption, args, config);
  }
  throw err;
}

/**
 * Handles the completion of an option name.
 * @param validator The option validator
 * @param prefix The name prefix, if any
 */
function handleNameCompletion(validator: OptionValidator, prefix?: string): never {
  const names = [...validator.names.keys()];
  const prefixedNames = prefix ? names.filter((name) => name.startsWith(prefix)) : names;
  throw new CompletionMessage(...prefixedNames);
}

/**
 * Checks the items of a requirement expression or object.
 * @param items The list of requirement items
 * @param itemFn The callback to execute on each item
 * @param error The terminal string error
 * @param negate True if the requirement should be negated
 * @param invert True if the requirements should be inverted
 * @param and If true, return on the first error; else return on the first success
 * @returns True if the requirement was satisfied
 */
async function checkRequireItems<T>(
  items: Array<T>,
  itemFn: (
    item: T,
    error: TerminalString,
    negate: boolean,
    invert: boolean,
  ) => boolean | Promise<boolean>,
  error: TerminalString,
  negate: boolean,
  invert: boolean,
  and: boolean,
): Promise<boolean> {
  if (!and && items.length > 1) {
    error.addOpening('(');
  }
  let first = true;
  for (const item of items) {
    if (and || first) {
      first = false;
    } else {
      error.addWord(invert ? 'and' : 'or');
    }
    const success = await itemFn(item, error, negate, invert);
    if (success !== and) {
      return success;
    }
  }
  if (and) {
    return true;
  }
  if (items.length > 1) {
    error.addClosing(')');
  }
  return false;
}

/**
 * Parses the value of an option parameter.
 * @param validator The option validator
 * @param values The option values
 * @param info The option information
 * @param param The option parameter
 * @param completing True if performing completion
 * @param suggestNames True if option names should be suggested on parse failures
 */
async function parseParam(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  info: OptionInfo,
  param: string,
  completing: boolean,
  suggestNames = false,
): Promise<void> {
  /** @ignore */
  function norm<T>(val: T) {
    return validator.normalize(option, name, val);
  }
  const { key, name, option } = info;
  const convertFn =
    option.type === 'boolean' ? isTrue : isString(option) ? (str: string) => str : Number;
  try {
    const parse = option.parse;
    let value;
    if (isArray(option)) {
      const vals = option.separator ? param.split(option.separator) : [param];
      const res = parse
        ? await Promise.all(vals.map((val) => parse(values, name, val)))
        : // eslint-disable-next-line @typescript-eslint/no-explicit-any
          vals.map(convertFn as any);
      value = values[key] as Array<unknown>;
      value.push(...res.map(norm));
    } else {
      const result = parse ? await parse(values, name, param) : convertFn(param);
      value = norm(result);
    }
    values[key] = norm(value);
  } catch (err) {
    // do not propagate errors during completion
    if (!completing) {
      if (err instanceof ErrorMessage && suggestNames) {
        handleUnknown(validator, param, err);
      }
      throw err;
    }
  }
}

/**
 * Resets the value of an array option.
 * @param values The option values
 * @param key The option key
 * @param option The option definition
 */
function resetValue(values: OpaqueOptionValues, key: string, option: OpaqueOption) {
  if (!option.append || values[key] === undefined) {
    values[key] = [];
  }
}

/**
 * Sets the normalized default value of an option.
 * @param validator The option validator
 * @param values The option values
 * @param key The option key
 * @param option The option definition
 */
async function setDefaultValue(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  key: string,
  option: OpaqueOption,
): Promise<void> {
  /** @ignore */
  function norm<T>(val: T) {
    return validator.normalize(option, key, val);
  }
  const def = option.default;
  if (def === undefined) {
    values[key] = undefined;
    return;
  }
  const value = await (typeof def === 'function' ? def(values) : def);
  values[key] =
    isUnknown(option) || isBoolean(option)
      ? value
      : isArray(option)
        ? norm(value.map(norm))
        : norm(value);
}

/**
 * Handles a niladic option.
 * @param validator The option validator
 * @param values The option values
 * @param specifiedKeys The set of specified keys
 * @param completing True if performing completion
 * @param rest The remaining command-line arguments
 * @param info The option information
 * @param warning The warnings accumulated so far
 * @param progName The program name
 * @returns [True if the parsing loop should be broken, number of additional processed arguments]
 */
async function handleNiladic(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  specifiedKeys: Set<string>,
  completing: boolean,
  rest: Array<string>,
  info: OptionInfo,
  warning: WarnMessage,
  progName?: string,
): Promise<[boolean, number]> {
  const { key, option, name } = info;
  switch (option.type) {
    case 'flag': {
      values[key] = !option.negationNames?.includes(name);
      return [false, 0];
    }
    case 'function': {
      const breakLoop = !!option.break && !completing;
      if (breakLoop) {
        await checkRequired(validator, values, specifiedKeys);
      }
      const res = await handleFunction(values, completing, rest, info);
      return [breakLoop, res];
    }
    case 'command': {
      if (!completing) {
        await checkRequired(validator, values, specifiedKeys);
      }
      const res = await handleCommand(validator, values, completing, rest, info);
      if (res.warning) {
        warning.push(...res.warning);
      }
      return [true, 0];
    }
    default: {
      // skip special options during completion
      if (!completing) {
        await handleSpecial(validator, rest, option, progName);
      }
      return [!completing, 0];
    }
  }
}

/**
 * Handles a function option.
 * @param values The option values
 * @param completing True if performing completion
 * @param rest The remaining command-line arguments
 * @param info The option information
 * @returns The number of additional processed arguments
 */
async function handleFunction(
  values: OpaqueOptionValues,
  completing: boolean,
  rest: Array<string>,
  info: OptionInfo,
): Promise<number> {
  const { key, option } = info;
  try {
    values[key] = await option.exec(values, completing, rest);
    return completing ? 0 : Math.max(0, option.skipCount ?? 0);
  } catch (err) {
    // do not propagate errors during completion
    if (!completing) {
      throw err;
    }
    return 0;
  }
}

/**
 * Handles a command option.
 * @param validator The option validator
 * @param values The option values
 * @param completing True if performing completion
 * @param rest The remaining command-line arguments
 * @param info The option information
 * @returns The result of parsing the command arguments
 */
async function handleCommand(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  completing: boolean,
  rest: Array<string>,
  info: OptionInfo,
): Promise<ParseResult> {
  const { key, option, name } = info;
  const { options, shortStyle } = option;
  const cmdOptions = typeof options === 'function' ? options() : options;
  const cmdValidator = new OptionValidator(cmdOptions, validator.config);
  const cmdValues: OpaqueOptionValues = {};
  const result = doParse(cmdValidator, cmdValues, rest, {
    compIndex: completing ? 1 : -1,
    progName: name,
    shortStyle,
  });
  if (!completing) {
    values[key] = await option.cmd(values, cmdValues);
  }
  return result;
}

/**
 * Handles a special option.
 * @param validator The option validator
 * @param rest The remaining command-line arguments
 * @param option The option definition
 * @param progName The program name
 * @returns A promise that must be awaited before continuing
 */
function handleSpecial(
  validator: OptionValidator,
  rest: Array<string>,
  option: OpaqueOption,
  progName?: string,
): void | Promise<void> {
  if (option.type === 'help') {
    const filters = option.useFilters && rest.map((arg) => RegExp(arg, 'i'));
    const formatter = new HelpFormatter(validator, option.format, filters);
    const sections = option.sections ?? [
      { type: 'usage', title: 'Usage:', indent: 2 },
      { type: 'groups', title: 'Options', phrase: '%s:' },
    ];
    throw formatter.formatSections(sections, progName);
  } else if (option.version) {
    throw new VersionMessage(option.version);
  } else if (option.resolve) {
    return resolveVersion(validator, option.resolve);
  }
}

/**
 * Handles the completion of an option that has a completion callback.
 * @param values The option values
 * @param complete The completion callback
 * @param rest The remaining command-line arguments
 * @param param The option parameter, if any
 * @returns A promise that must be awaited before continuing
 */
async function handleComplete(
  values: OpaqueOptionValues,
  complete: CompleteCallback,
  rest: Array<string>,
  param = '',
): Promise<void> {
  let words;
  try {
    words = await complete(values, param, rest);
  } catch (err) {
    // do not propagate errors during completion
    throw new CompletionMessage();
  }
  throw new CompletionMessage(...words);
}

/**
 * Checks if required options were correctly specified.
 * This should only be called when completion is not in effect.
 * @param validator The option validator
 * @param values The option values
 * @param specifiedKeys The set of specified keys
 */
async function checkRequired(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  specifiedKeys: Set<string>,
) {
  /** @ignore */
  function checkEnv(key: string) {
    return checkEnvVarAndDefaultValue(validator, values, specifiedKeys, key);
  }
  /** @ignore */
  function checkReq(key: string) {
    return checkRequiredOption(validator, values, specifiedKeys, key);
  }
  const keys = Object.keys(validator.options);
  await Promise.all(keys.map(checkEnv));
  await Promise.all(keys.map(checkReq));
}

/**
 * Checks if there is an environment variable or default value for an option.
 * @param validator The option validator
 * @param values The option values
 * @param specifiedKeys The set of specified keys
 * @param key The option key
 * @returns A promise that must be awaited before continuing
 */
async function checkEnvVarAndDefaultValue(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  specifiedKeys: Set<string>,
  key: string,
): Promise<void> {
  const option = validator.options[key];
  const envVar = option.envVar;
  if (envVar && (await readEnvVar(validator, values, { key, option, name: envVar }))) {
    specifiedKeys.add(key);
  } else if (option.required) {
    const name = option.preferredName ?? '';
    throw validator.error(ErrorItem.missingRequiredOption, { o: name });
  } else if ('default' in option) {
    return setDefaultValue(validator, values, key, option);
  }
}

/**
 * Checks the requirements of an option.
 * @param validator The option validator
 * @param values The option values
 * @param specifiedKeys The set of specified keys
 * @param key The option key
 */
async function checkRequiredOption(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  specifiedKeys: Set<string>,
  key: string,
) {
  /** @ignore */
  function check(requires: Requires, negate: boolean, invert: boolean) {
    return checkRequires(validator, values, specifiedKeys, requires, error, negate, invert);
  }
  const option = validator.options[key];
  const specified = specifiedKeys.has(key);
  const error = new TerminalString();
  if (
    (specified && option.requires && !(await check(option.requires, false, false))) ||
    (!specified && option.requiredIf && !(await check(option.requiredIf, true, true)))
  ) {
    const name = option.preferredName ?? '';
    const kind = specified
      ? ErrorItem.unsatisfiedRequirement
      : ErrorItem.unsatisfiedCondRequirement;
    throw validator.error(kind, { o: name, p: error });
  }
}

/**
 * Checks the requirements of an option that was specified.
 * @param validator The option validator
 * @param values The option values
 * @param specifiedKeys The set of specified keys
 * @param requires The option requirements
 * @param error The terminal string error
 * @param negate True if the requirements should be negated
 * @param invert True if the requirements should be inverted
 * @returns True if the requirements were satisfied
 */
async function checkRequires(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  specifiedKeys: Set<string>,
  requires: Requires,
  error: TerminalString,
  negate: boolean,
  invert: boolean,
): Promise<boolean> {
  /** @ignore */
  function checkItem(requires: Requires, error: TerminalString, negate: boolean, invert: boolean) {
    return checkRequires(validator, values, specifiedKeys, requires, error, negate, invert);
  }
  /** @ignore */
  function checkEntry(
    entry: RequiresEntry,
    error: TerminalString,
    negate: boolean,
    invert: boolean,
  ) {
    return checkRequirement(validator, values, specifiedKeys, entry, error, negate, invert);
  }
  if (typeof requires === 'string') {
    return checkEntry([requires, undefined], error, negate, invert);
  }
  if (requires instanceof RequiresNot) {
    return checkItem(requires.item, error, !negate, invert);
  }
  if (requires instanceof RequiresAll || requires instanceof RequiresOne) {
    const and = requires instanceof RequiresAll !== negate;
    return checkRequireItems(requires.items, checkItem, error, negate, invert, and);
  }
  if (typeof requires === 'object') {
    const entries = Object.entries(requires);
    return checkRequireItems(entries, checkEntry, error, negate, invert, !negate);
  }
  if ((await requires(values)) == negate) {
    if (negate != invert) {
      error.addWord('not');
    }
    format.v(requires, validator.config.styles, error);
    return false;
  }
  return true;
}

/**
 * Checks if a required option was specified with correct values.
 * @param validator The option validator
 * @param values The option values
 * @param specifiedKeys The set of specified keys
 * @param entry The required option key and value
 * @param error The terminal string error
 * @param negate True if the requirement should be negated
 * @param invert True if the requirements should be inverted
 * @returns True if the requirement was satisfied
 */
function checkRequirement(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  specifiedKeys: Set<string>,
  entry: RequiresEntry,
  error: TerminalString,
  negate: boolean,
  invert: boolean,
): boolean {
  const [key, value] = entry;
  const actual = values[key];
  const option = validator.options[key];
  const specified = specifiedKeys.has(key) || actual !== undefined; // consider default values
  const required = value !== null;
  if (isSpecial(option) || isUnknown(option) || !specified || !required || value === undefined) {
    if ((specified == required) != negate) {
      return true;
    }
    if (specified != invert) {
      error.addWord('no');
    }
    format.o(option.preferredName ?? '', validator.config.styles, error);
    return false;
  }
  const spec = isBoolean(option) ? 'b' : isString(option) ? 's' : 'n';
  return checkRequiredValue(validator, option, negate, invert, actual, value, error, spec);
}

/**
 * Checks the required value of an option against a specified value.
 * @template T The type of the option value
 * @param validator The option validator
 * @param option The option definition
 * @param negate True if the requirement should be negated
 * @param invert True if the requirements should be inverted
 * @param actual The specified value
 * @param value The required value
 * @param error The terminal string error
 * @param spec The formatting specification
 * @returns True if the requirement was satisfied
 */
function checkRequiredValue<T>(
  validator: OptionValidator,
  option: OpaqueOption,
  negate: boolean,
  invert: boolean,
  actual: T,
  value: T,
  error: TerminalString,
  spec: string,
): boolean {
  /** @ignore */
  function norm<T>(val: T) {
    return validator.normalize(option, name, val);
  }
  const name = option.preferredName ?? '';
  const array = Array.isArray(value);
  const expected = array ? norm(value.map(norm)) : norm(value);
  if (array) {
    if (
      checkRequiredArray(
        actual as ReadonlyArray<T>,
        expected as ReadonlyArray<T>,
        negate,
        !!option.unique,
      )
    ) {
      return true;
    }
  } else if ((actual === expected) !== negate) {
    return true;
  }
  const styles = validator.config.styles;
  format.o(name, styles, error);
  error.addWord(negate != invert ? '!=' : '=');
  const phrase = array ? `[%${spec}]` : `%${spec}`;
  error.formatArgs(styles, phrase, { [spec]: expected });
  return false;
}
