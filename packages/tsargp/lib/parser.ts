//--------------------------------------------------------------------------------------------------
// Imports
//--------------------------------------------------------------------------------------------------
import type {
  Options,
  OptionValues,
  OpaqueOptionValues,
  Requires,
  RequiresVal,
  CompleteCallback,
  ResolveCallback,
  OpaqueOption,
  OptionValue,
} from './options';
import type { OptionInfo, ConcreteConfig, ValidatorConfig } from './validator';

import { ErrorItem } from './enums';
import { HelpFormatter } from './formatter';
import {
  RequiresAll,
  RequiresNot,
  RequiresOne,
  isArray,
  isVariadic,
  isNiladic,
  isSpecial,
  isString,
  isBoolean,
  isUnknown,
} from './options';
import {
  Message,
  ErrorMessage,
  WarnMessage,
  VersionMessage,
  CompletionMessage,
  TerminalString,
  FormatConfig,
} from './styles';
import { OptionValidator, defaultConfig } from './validator';
import { format } from './styles';
import { checkRequiredArray, findSimilarNames, getArgs, isTrue } from './utils';

//--------------------------------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------------------------------
/**
 * The kind of current argument in the parser loop.
 */
const enum ArgKind {
  marker,
  positional,
  inline,
  param,
}

//--------------------------------------------------------------------------------------------------
// Types
//--------------------------------------------------------------------------------------------------
/**
 * The parse configuration.
 */
export type ParseConfig = {
  /**
   * The program name.
   */
  readonly progName?: string;
  /**
   * The completion index of a raw command line.
   */
  readonly compIndex?: number;
  /**
   * True if the first argument is expected to be an option cluster (i.e., short-option style).
   */
  readonly shortStyle?: true;
};

/**
 * The parse result.
 */
export type ParseResult = {
  /**
   * A list of promises that resolve the async callbacks. Can be ignored if empty.
   */
  readonly promises: Array<Promise<void>>;
  /**
   * A list of warnings generated by the parser. Can be ignored if empty.
   */
  readonly warnings: WarnMessage;
};

//--------------------------------------------------------------------------------------------------
// Classes
//--------------------------------------------------------------------------------------------------
/**
 * Implements parsing of command-line arguments into option values.
 * @template T The type of the option definitions
 */
export class ArgumentParser<T extends Options = Options> {
  private readonly validator: OptionValidator;

  /**
   * Creates an argument parser based on a set of option definitions.
   * @param options The option definitions
   * @param config The validator configuration
   */
  constructor(options: T, config: ValidatorConfig = {}) {
    const concreteConfig: ConcreteConfig = {
      styles: Object.assign({}, defaultConfig.styles, config.styles),
      phrases: Object.assign({}, defaultConfig.phrases, config.phrases),
    };
    this.validator = new OptionValidator(options, concreteConfig);
  }

  /**
   * Validates the option definitions. This should only be called during development and in unit
   * tests, but should be skipped in production.
   * @returns A list of validation warnings
   */
  validate(): WarnMessage {
    return this.validator.validate();
  }

  /**
   * Convenience method to parse command-line arguments into option values.
   * @param command The raw command line or command-line arguments
   * @param config The parse configuration
   * @returns The options' values
   */
  parse(command?: string | Array<string>, config?: ParseConfig): OptionValues<T> {
    const values = {} as OptionValues<T>;
    this.doParse(values, command, config);
    return values;
  }

  /**
   * Async version. Use this if the option definitions contain async callbacks.
   * @param command The raw command line or command-line arguments
   * @param config The parse configuration
   * @returns A promise that resolves to the options' values
   */
  async parseAsync(
    command?: string | Array<string>,
    config?: ParseConfig,
  ): Promise<OptionValues<T>> {
    const values = {} as OptionValues<T>;
    await Promise.all(this.doParse(values, command, config).promises);
    return values;
  }

  /**
   * Parses command-line arguments into option values.
   * @param values The options' values to parse into
   * @param command The raw command line or command-line arguments
   * @param config The parse configuration
   * @returns A promise that can be awaited in order to resolve async callbacks
   */
  parseInto(
    values: OptionValues<T>,
    command?: string | Array<string>,
    config?: ParseConfig,
  ): Promise<Array<void>> {
    return Promise.all(this.doParse(values, command, config).promises);
  }

  /**
   * Parses command-line arguments into option values.
   * @param values The options' values to parse into
   * @param command The raw command line or command-line arguments
   * @param config The parse configuration
   * @returns The parse result
   */
  doParse(
    values: OptionValues<T>,
    command?: string | Array<string>,
    config?: ParseConfig,
  ): ParseResult {
    const { promises, warnings } = createLoop(this.validator, values, command, config).loop();
    return { promises, warnings };
  }

  /**
   * Tries to parse command-line arguments into option values.
   * @param values The options' values to parse into
   * @param command The raw command line or command-line arguments
   * @param config The parse configuration
   * @returns The parse error or message, if any
   */
  async tryParse(
    values: OptionValues<T>,
    command?: string | Array<string>,
    config?: ParseConfig,
  ): Promise<Error | Message | null> {
    try {
      const { promises, warnings } = this.doParse(values, command, config);
      await Promise.all(promises);
      return warnings.length ? warnings : null;
    } catch (err) {
      return err as Error | Message;
    }
  }
}

/**
 * Implements the parsing loop.
 * @internal
 */
class ParserLoop {
  private readonly specifiedKeys = new Set<string>();
  readonly promises = new Array<Promise<void>>();
  readonly warnings = new WarnMessage();

  /**
   * Creates a parser loop.
   * @param validator The option validator
   * @param values The option values
   * @param args The command-line arguments
   * @param completing True if performing completion
   * @param progName The program name, if any
   * @param shortStyle True if the first argument is expected to be an option cluster
   */
  constructor(
    private readonly validator: OptionValidator,
    private readonly values: OpaqueOptionValues,
    private readonly args: Array<string>,
    private readonly completing: boolean,
    private readonly progName?: string,
    shortStyle = false,
  ) {
    if (!completing && progName && process?.title) {
      process.title += ' ' + progName;
    }
    for (const key in validator.options) {
      if (!(key in values)) {
        const option = validator.options[key];
        if (!isSpecial(option)) {
          values[key] = undefined;
        }
      }
    }
    if (shortStyle) {
      parseCluster(validator, args);
    }
  }

  /**
   * Loops through the command-line arguments.
   * @returns The parser loop instance
   */
  loop(): this {
    /** @ignore */
    function assert(_condition: unknown): asserts _condition {}
    /** @ignore */
    function suggestName(option: OpaqueOption): boolean {
      return (
        argKind === ArgKind.positional ||
        (argKind === ArgKind.param && isArray(option) && isVariadic(option))
      );
    }

    let argKind: ArgKind | undefined;
    let singleParam = false;
    let value: string | undefined;
    let current: OptionInfo | undefined;

    for (let i = 0; i < this.args.length; ++i) {
      const [arg, comp] = this.args[i].split('\0', 2);
      if (argKind === ArgKind.marker || singleParam) {
        value = arg;
      } else {
        [argKind, current, value] = parseOption(this.validator, arg, comp !== undefined, current);
        if (argKind !== ArgKind.param) {
          if (!this.specifiedKeys.has(current.key)) {
            if (current.option.deprecated) {
              const warning = this.validator.format(ErrorItem.deprecatedOption, {
                o: current.name,
              });
              this.warnings.push(warning);
            }
            this.specifiedKeys.add(current.key);
          }
          if (isArray(current.option)) {
            resetValue(this.values, current.key, current.option);
          }
        }
      }
      assert(current);
      const { key, name, option } = current;
      if (isNiladic(option)) {
        if (comp !== undefined) {
          // assert(value !== undefined);
          throw new CompletionMessage();
        } else if (!this.completing && value !== undefined) {
          throw this.validator.error(ErrorItem.disallowedInlineValue, { o: name }, { alt: 0 });
        } else if (
          handleNiladic(
            this.validator,
            this.values,
            this.specifiedKeys,
            this.completing,
            this.args,
            this.promises,
            key,
            option,
            name,
            i,
            this.progName,
          )
        ) {
          return this;
        }
        current = undefined;
      } else if (comp !== undefined) {
        if (option.complete) {
          handleComplete(this.values, option.complete, this.args, this.promises, i, value);
          return this;
        }
        handleCompletion(option, value);
        if (suggestName(option)) {
          handleNameCompletion(this.validator, value);
        }
        throw new CompletionMessage();
      } else if (value !== undefined) {
        try {
          parseValue(this.validator, this.values, key, option, name, value);
        } catch (err) {
          // do not propagate errors during completion
          if (!this.completing) {
            if (err instanceof ErrorMessage && suggestName(option)) {
              handleUnknown(this.validator, value, err);
            }
            throw err;
          }
        }
        if (singleParam) {
          singleParam = false;
          current = undefined;
        }
      } else if (isArray(option) && isVariadic(option)) {
        continue;
      } else if (i + 1 == this.args.length) {
        throw this.validator.error(ErrorItem.missingParameter, { o: name });
      } else if (argKind !== ArgKind.marker) {
        singleParam = true;
      }
    }
    // assert(!this.completing);
    checkRequired(this.validator, this.values, this.specifiedKeys);
    return this;
  }
}

//--------------------------------------------------------------------------------------------------
// Functions
//--------------------------------------------------------------------------------------------------
/**
 * Parses the first argument which is expected to be an option cluster.
 * @param validator The option validator
 * @param args The command-line arguments
 */
function parseCluster(validator: OptionValidator, args: Array<string>) {
  const cluster = args.shift();
  if (!cluster) {
    return;
  }
  for (let j = 0, i = 0; j < cluster.length; ++j) {
    const letter = cluster[j];
    if (letter === '-' && j == 0) {
      continue; // skip the first dash in the cluster
    }
    if (letter === '\0') {
      throw new CompletionMessage();
    }
    const key = validator.letters.get(letter);
    if (!key) {
      throw validator.error(ErrorItem.unknownOption, { o: letter }, { alt: 0 });
    }
    const option = validator.options[key];
    if (
      j < cluster.length - 1 &&
      (option.type === 'command' || (isArray(option) && isVariadic(option)))
    ) {
      throw validator.error(ErrorItem.invalidClusterOption, { o: letter });
    }
    const name = option.names?.find((name) => name);
    if (!name) {
      continue; // skip options with no names
    }
    args.splice(i, 0, name);
    i += isNiladic(option) ? 1 : 2;
  }
}

/**
 * Checks if the environment variable of an option is present, and reads its value.
 * @param validator The option validator
 * @param values The options' values to parse into
 * @param option The option definition
 * @param key The option key
 * @returns True if the environment variable was found
 */
function checkEnvVar(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  option: OpaqueOption,
  key: string,
): boolean {
  if (option.envVar) {
    const value = process?.env[option.envVar];
    if (value) {
      if (option.type === 'flag') {
        values[key] = isTrue(value);
      } else {
        if (isArray(option)) {
          resetValue(values, key, option);
        }
        parseValue(validator, values, key, option, option.envVar, value);
      }
      return true;
    }
  }
  return false;
}

/**
 * Creates a parser loop.
 * @param validator The option validator
 * @param values The options' values to parse into
 * @param command The raw command line or command-line arguments
 * @param config The parse configuration
 * @returns The parser loop instance
 */
function createLoop(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  command = process?.env['COMP_LINE'] ?? process?.argv.slice(2) ?? [],
  config: ParseConfig = { compIndex: Number(process?.env['COMP_POINT']) },
): ParserLoop {
  let args, progName;
  if (typeof command === 'string') {
    [progName, ...args] = getArgs(command, config.compIndex);
  } else {
    [progName, args] = [config.progName, command];
    if (progName === undefined) {
      progName = process?.argv[1].split(/[\\/]/).at(-1);
    }
  }
  const completing = (config.compIndex ?? -1) >= 0;
  return new ParserLoop(validator, values, args, completing, progName, config.shortStyle);
}

/**
 * Parses an option from a command-line argument.
 * @param validator The option validator
 * @param arg The current argument
 * @param comp True if completing at the current iteration
 * @param current The current option information, if any
 * @returns A tuple of [ArgKind, current, value]
 */
function parseOption(
  validator: OptionValidator,
  arg: string,
  comp: boolean,
  current?: OptionInfo,
): [ArgKind, OptionInfo, string | undefined] {
  const [name, value] = arg.split(/=(.*)/, 2);
  const key = validator.names.get(name);
  if (key) {
    if (comp && value === undefined) {
      throw new CompletionMessage(name);
    }
    if (validator.positional && name === validator.positional.marker) {
      if (comp) {
        throw new CompletionMessage();
      }
      if (value !== undefined) {
        throw validator.error(ErrorItem.disallowedInlineValue, { o: name }, { alt: 1 });
      }
      return [ArgKind.marker, validator.positional, undefined];
    }
    current = { key, name, option: validator.options[key] };
    return [ArgKind.inline, current, value];
  }
  if (!current) {
    if (!validator.positional) {
      if (comp) {
        handleNameCompletion(validator, arg);
      }
      handleUnknown(validator, name);
    }
    return [ArgKind.positional, validator.positional, arg];
  }
  return [ArgKind.param, current, arg];
}

/**
 * Resolve a package version using a module-resolve function.
 * @param validator The option validator
 * @param resolve The resolve callback
 */
async function resolveVersion(
  validator: OptionValidator,
  resolve: ResolveCallback,
): Promise<never> {
  const { promises } = await import('fs');
  for (
    let path = './package.json', lastResolved = '', resolved = resolve(path);
    resolved != lastResolved;
    path = '../' + path, lastResolved = resolved, resolved = resolve(path)
  ) {
    try {
      const jsonData = await promises.readFile(new URL(resolved));
      const { version } = JSON.parse(jsonData.toString());
      throw new VersionMessage(version);
    } catch (err) {
      if ((err as ErrnoException).code != 'ENOENT') {
        throw err;
      }
    }
  }
  throw validator.error(ErrorItem.missingPackageJson);
}

/**
 * Handles the completion of an option with a parameter.
 * @param option The option definition
 * @param param The option parameter
 */
function handleCompletion(option: OpaqueOption, param?: string) {
  let words =
    option.type === 'boolean'
      ? ['true', 'false']
      : option.enums
        ? option.enums.map((val) => `${val}`)
        : [];
  if (words.length && param) {
    words = words.filter((word) => word.startsWith(param));
  }
  if (words.length) {
    throw new CompletionMessage(...words);
  }
}

/**
 * Handles an unknown option.
 * @param validator The option validator
 * @param name The unknown option name
 * @param err The previous error message, if any
 */
function handleUnknown(validator: OptionValidator, name: string, err?: ErrorMessage): never {
  const similar = findSimilarNames(name, [...validator.names.keys()], 0.6);
  const [args, alt] = similar.length ? [{ o1: name, o2: similar }, 1] : [{ o: name }, 0];
  const config: FormatConfig = { alt, sep: ',' };
  if (err) {
    err.msg.push(validator.format(ErrorItem.parseError, args, config));
  } else {
    err = validator.error(ErrorItem.unknownOption, args, config);
  }
  throw err;
}

/**
 * Handles the completion of an option name.
 * @param validator The option validator
 * @param prefix The name prefix, if any
 */
function handleNameCompletion(validator: OptionValidator, prefix?: string): never {
  const names = [...validator.names.keys()];
  const prefixedNames = prefix ? names.filter((name) => name.startsWith(prefix)) : names;
  throw new CompletionMessage(...prefixedNames);
}

/**
 * Checks the items of a requirement expression or object.
 * @param items The list of requirement items
 * @param itemFn The callback to execute on each item
 * @param error The terminal string error
 * @param negate True if the requirement should be negated
 * @param invert True if the requirements should be inverted
 * @param and If true, return on the first error; else return on the first success
 * @returns True if the requirement was satisfied
 */
function checkRequireItems<T>(
  items: Array<T>,
  itemFn: (item: T, error: TerminalString, negate: boolean, invert: boolean) => boolean,
  error: TerminalString,
  negate: boolean,
  invert: boolean,
  and: boolean,
): boolean {
  if (!and && items.length > 1) {
    error.addOpening('(');
  }
  let first = true;
  for (const item of items) {
    if (and || first) {
      first = false;
    } else {
      error.addWord(invert ? 'and' : 'or');
    }
    const success = itemFn(item, error, negate, invert);
    if (success !== and) {
      return success;
    }
  }
  if (and) {
    return true;
  }
  if (items.length > 1) {
    error.addClosing(')');
  }
  return false;
}

/**
 * Parses the value of an array option parameter.
 * @template T The type of the option value
 * @param validator The option validator
 * @param values The option values
 * @param key The option key
 * @param option The option definition
 * @param name The option name (as specified on the command-line)
 * @param value The parameter value
 * @param convertFn The function to convert from string
 */
function parseArray<T>(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  key: string,
  option: OpaqueOption,
  name: string,
  value: string,
  convertFn: (value: string) => T,
) {
  /** @ignore */
  function norm<T>(val: T) {
    return validator.normalize(option, name, val);
  }
  /** @ignore */
  function append(vals: Array<T>) {
    return function (prev: Array<T>) {
      prev.push(...vals.map(norm));
      return norm(prev);
    };
  }
  let result: Array<T> | Promise<Array<T>>;
  let previous = values[key] as typeof result;
  const vals = option.separator ? value.split(option.separator) : [value];
  if (option.parse) {
    let prevSync: Array<T> = [];
    for (const val of vals) {
      const res = option.parse(values, name, val);
      if (res instanceof Promise) {
        const copy = prevSync; // save the reference for the closure
        const prev = previous; // save the reference for the closure
        previous = res.then(async (val) => append([...copy, val as T])(await prev));
        prevSync = []; // reset for incoming values
      } else {
        prevSync.push(res as T);
      }
    }
    result =
      previous instanceof Promise
        ? prevSync.length
          ? previous.then(append(prevSync))
          : previous
        : prevSync;
  } else {
    result = vals.map(convertFn);
  }
  values[key] =
    result instanceof Promise
      ? result
      : previous instanceof Promise
        ? previous.then(append(result))
        : append(result)(previous);
}

/**
 * Parses the value of a single-valued option parameter.
 * @template T The type of the option value
 * @param validator The option validator
 * @param values The option values
 * @param key The option key
 * @param option The option definition
 * @param name The option name (as specified on the command-line)
 * @param value The parameter value
 * @param convertFn The function to convert from string
 */
function parseSingle<T>(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  key: string,
  option: OpaqueOption,
  name: string,
  value: string,
  convertFn: (value: string) => T,
) {
  const result = option.parse ? option.parse(values, name, value) : convertFn(value);
  setSingle(validator, values, key, option, name, result);
}

/**
 * Gets the value of a single-valued option parameter.
 * @template T The type of the option value
 * @param validator The option validator
 * @param values The option values
 * @param key The option key
 * @param option The option definition
 * @param name The option name (as specified on the command-line)
 * @param value The parameter value
 */
function setSingle<T>(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  key: string,
  option: OpaqueOption,
  name: string,
  value: T | Promise<T>,
) {
  /** @ignore */
  function norm<T>(val: T) {
    return validator.normalize(option, name, val);
  }
  values[key] = value instanceof Promise ? value.then(norm) : norm(value);
}

/**
 * Gets the value of an array-valued option parameter.
 * @template T The type of the option value
 * @param validator The option validator
 * @param values The option values
 * @param key The option key
 * @param option The option definition
 * @param name The option name (as specified on the command-line)
 * @param value The parameter value
 */
function setArray<T>(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  key: string,
  option: OpaqueOption,
  name: string,
  value: ReadonlyArray<T> | Promise<ReadonlyArray<T>>,
) {
  /** @ignore */
  function norm<T>(val: T) {
    return validator.normalize(option, name, val);
  }
  values[key] =
    value instanceof Promise ? value.then((vals) => norm(vals.map(norm))) : norm(value.map(norm));
}

/**
 * Parses the value of an option parameter.
 * @param validator The option validator
 * @param values The option values
 * @param key The option key
 * @param option The option definition
 * @param name The option name (as specified on the command-line)
 * @param value The parameter value
 */
function parseValue(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  key: string,
  option: OpaqueOption,
  name: string,
  value: string,
) {
  const parseFn = isArray(option) ? parseArray : parseSingle;
  const convertFn =
    option.type === 'boolean'
      ? isTrue
      : option.type === 'string' || option.type === 'strings'
        ? (str: string) => str
        : Number;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  parseFn(validator, values, key, option, name, value, convertFn as any);
}

/**
 * Resets the value of an array option.
 * @param values The option values
 * @param key The option key
 * @param option The option definition
 */
function resetValue(values: OpaqueOptionValues, key: string, option: OpaqueOption) {
  if (!option.append || values[key] === undefined) {
    values[key] = [];
  }
}

/**
 * Checks the required value of a single-parameter option against a specified value.
 * @template T The type of the option value
 * @param validator The option validator
 * @param values The option values
 * @param option The option definition
 * @param negate True if the requirement should be negated
 * @param invert True if the requirements should be inverted
 * @param key The required option key
 * @param value The required value
 * @param error The terminal string error
 * @param spec The formatting specification
 * @returns True if the requirement was satisfied
 */
function checkSingle<T>(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  option: OpaqueOption,
  negate: boolean,
  invert: boolean,
  key: string,
  value: T,
  error: TerminalString,
  spec: string,
): boolean {
  const actual = values[key] as T | Promise<T>;
  if (actual instanceof Promise) {
    return true; // ignore promises during requirement checking
  }
  const name = option.preferredName ?? '';
  const expected = validator.normalize(option, name, value);
  if ((actual === expected) !== negate) {
    return true;
  }
  const styles = validator.config.styles;
  format.o(name, styles, error);
  error.addWord(negate != invert ? '!=' : '=');
  error.formatArgs(styles, `%${spec}`, { [spec]: expected });
  return false;
}

/**
 * Checks the required value of an array option against a specified value.
 * @template T The type of the option value
 * @param validator The option validator
 * @param values The option values
 * @param option The option definition
 * @param negate True if the requirement should be negated
 * @param invert True if the requirements should be inverted
 * @param key The required option key
 * @param value The required value
 * @param error The terminal string error
 * @param spec The formatting specification
 * @returns True if the requirement was satisfied
 */
function checkArray<T>(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  option: OpaqueOption,
  negate: boolean,
  invert: boolean,
  key: string,
  value: ReadonlyArray<T>,
  error: TerminalString,
  spec: string,
): boolean {
  const actual = values[key] as Array<T> | Promise<Array<T>>;
  if (actual instanceof Promise) {
    return true; // ignore promises during requirement checking
  }
  const name = option.preferredName ?? '';
  const expected = value.map((val) => validator.normalize(option, name, val));
  if (checkRequiredArray(actual, expected, negate, option.unique === true)) {
    return true;
  }
  const styles = validator.config.styles;
  format.o(name, styles, error);
  error.addWord(negate != invert ? '!=' : '=');
  error.formatArgs(styles, `[%${spec}]`, { [spec]: expected });
  return false;
}

/**
 * Checks an option's required value against a specified value.
 * @param validator The option validator
 * @param values The option values
 * @param option The option definition
 * @param negate True if the requirement should be negated
 * @param invert True if the requirements should be inverted
 * @param key The required option key (to get the specified value)
 * @param value The required value
 * @param error The terminal string error
 * @returns True if the requirement was satisfied
 */
function checkRequiredValue(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  option: OpaqueOption,
  negate: boolean,
  invert: boolean,
  key: string,
  value: OptionValue,
  error: TerminalString,
): boolean {
  const checkFn = isArray(option) ? checkArray : checkSingle;
  const spec = isBoolean(option) ? 'b' : isString(option) ? 's' : 'n';
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return checkFn(validator, values, option, negate, invert, key, value as any, error, spec);
}

/**
 * Sets the normalized default value of an option.
 * @param validator The option validator
 * @param values The option values
 * @param key The option key
 * @param option The option definition
 */
function setDefaultValue(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  key: string,
  option: OpaqueOption,
) {
  if (option.default === undefined) {
    values[key] = undefined;
  } else {
    const value = typeof option.default === 'function' ? option.default(values) : option.default;
    if (option.type === 'flag' || option.type === 'boolean') {
      values[key] = value;
    } else {
      const setFn = isArray(option) ? setArray : setSingle;
      setFn(validator, values, key, option, key, value);
    }
  }
}

/**
 * Handles a niladic option.
 * @param validator The option validator
 * @param values The option values
 * @param specifiedKeys The set of specified keys
 * @param completing True if performing completion
 * @param args The command-line arguments
 * @param promises The list of promises
 * @param key The option key
 * @param option The option definition
 * @param name The option name (as specified in the command-line)
 * @param index The current argument index
 * @param progName The program name
 * @returns True if the parsing loop should be broken
 */
function handleNiladic(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  specifiedKeys: Set<string>,
  completing: boolean,
  args: Array<string>,
  promises: Array<Promise<void>>,
  key: string,
  option: OpaqueOption,
  name: string,
  index: number,
  progName?: string,
): boolean {
  switch (option.type) {
    case 'flag':
      values[key] = !option.negationNames?.includes(name);
      return false;
    case 'function':
      return handleFunction(
        validator,
        values,
        specifiedKeys,
        completing,
        args,
        promises,
        key,
        option,
        index,
      );
    case 'command':
      return handleCommand(
        validator,
        values,
        specifiedKeys,
        completing,
        args,
        promises,
        key,
        option,
        name,
        index,
      );
    default:
      if (completing) {
        return false; // skip special options during completion
      }
      return handleSpecial(validator, args, promises, option, index, progName);
  }
}

/**
 * Handles a function option.
 * @param validator The option validator
 * @param values The option values
 * @param specifiedKeys The set of specified keys
 * @param completing True if performing completion
 * @param args The command-line arguments
 * @param promises The list of promises
 * @param key The option key
 * @param option The option definition
 * @param index The current argument index
 * @returns True if the parsing loop should be broken
 */
function handleFunction(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  specifiedKeys: Set<string>,
  completing: boolean,
  args: Array<string>,
  promises: Array<Promise<void>>,
  key: string,
  option: OpaqueOption,
  index: number,
): boolean {
  const result = !!option.break && !completing;
  if (result) {
    checkRequired(validator, values, specifiedKeys);
  }
  try {
    const result = option.exec(values, completing, args.slice(index + 1));
    if (!completing && option.skipCount) {
      args.splice(index + 1, Math.max(0, option.skipCount));
    }
    if (result instanceof Promise) {
      promises.push(
        result.then(
          (val) => {
            values[key] = val;
          },
          (err) => {
            // do not propagate errors during completion
            if (!completing) {
              throw err;
            }
          },
        ),
      );
    } else {
      values[key] = result;
    }
  } catch (err) {
    // do not propagate errors during completion
    if (!completing) {
      throw err;
    }
  }
  return result;
}

/**
 * Handles a command option.
 * @param validator The option validator
 * @param values The option values
 * @param specifiedKeys The set of specified keys
 * @param completing True if performing completion
 * @param args The command-line arguments
 * @param promises The list of promises
 * @param key The option key
 * @param option The option definition
 * @param name The option name (as specified in the command-line)
 * @param index The current argument index
 * @returns True to break parsing loop (always)
 */
function handleCommand(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  specifiedKeys: Set<string>,
  completing: boolean,
  args: Array<string>,
  promises: Array<Promise<void>>,
  key: string,
  option: OpaqueOption,
  name: string,
  index: number,
): true {
  if (!completing) {
    checkRequired(validator, values, specifiedKeys);
  }
  const newValues: OpaqueOptionValues = {};
  const options = typeof option.options === 'function' ? option.options() : option.options;
  const newValidator = new OptionValidator(options, validator.config);
  const loop = new ParserLoop(
    newValidator,
    newValues,
    args.slice(index + 1),
    completing,
    name,
    option.shortStyle,
  ).loop();
  promises.push(...loop.promises);
  if (!completing) {
    const result = option.cmd(values, newValues);
    if (result instanceof Promise) {
      promises.push(
        result.then((val) => {
          values[key] = val;
        }),
      );
    } else {
      values[key] = result;
    }
  }
  return true;
}

/**
 * Handles a special option.
 * @param validator The option validator
 * @param args The command-line arguments
 * @param promises The list of promises
 * @param option The option definition
 * @param index The current argument index
 * @param progName The program name
 * @returns True if the parsing loop should be broken
 */
function handleSpecial(
  validator: OptionValidator,
  args: Array<string>,
  promises: Array<Promise<void>>,
  option: OpaqueOption,
  index: number,
  progName?: string,
): boolean {
  if (option.type === 'help') {
    const filters = option.useFilters && args.slice(index + 1).map((arg) => RegExp(arg, 'i'));
    const formatter = new HelpFormatter(validator, option.format, filters);
    const sections = option.sections ?? [
      { type: 'usage', title: 'Usage:', indent: 2 },
      { type: 'groups', title: 'Options', phrase: '%s:' },
    ];
    throw formatter.formatSections(sections, progName);
  } else if (option.version) {
    throw new VersionMessage(option.version);
  } else if (option.resolve) {
    const promise = resolveVersion(validator, option.resolve);
    promises.push(promise);
  }
  return true;
}

/**
 * Handles the completion of an option that has a completion callback.
 * @param values The option values
 * @param complete The completion callback
 * @param args The command-line arguments
 * @param promises The list of promises
 * @param index The current argument index
 * @param param The option parameter, if any
 */
function handleComplete(
  values: OpaqueOptionValues,
  complete: CompleteCallback,
  args: Array<string>,
  promises: Array<Promise<void>>,
  index: number,
  param = '',
) {
  let result;
  try {
    result = complete(values, param, args.slice(index + 1));
  } catch (err) {
    // do not propagate errors during completion
    throw new CompletionMessage();
  }
  if (Array.isArray(result)) {
    throw new CompletionMessage(...result);
  }
  const promise = result.then(
    (words) => {
      throw new CompletionMessage(...words);
    },
    () => {
      // do not propagate errors during completion
      throw new CompletionMessage();
    },
  );
  promises.push(promise);
}

/**
 * Checks if required options were correctly specified.
 * Sets option values to their env. var. or default value, if not previously set.
 * This should only be called when completion is not in effect.
 * @param validator The option validator
 * @param values The option values
 * @param specifiedKeys The set of specified keys
 */
function checkRequired(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  specifiedKeys: Set<string>,
) {
  for (const key in validator.options) {
    if (!specifiedKeys.has(key)) {
      const option = validator.options[key];
      if (checkEnvVar(validator, values, option, key)) {
        specifiedKeys.add(key); // need this for checking requirements in the second loop
        continue;
      }
      const name = option.preferredName ?? '';
      if (option.required) {
        throw validator.error(ErrorItem.missingRequiredOption, { o: name });
      }
      if (option.requiredIf) {
        const error = new TerminalString();
        if (
          !checkRequires(validator, values, specifiedKeys, option.requiredIf, error, true, true)
        ) {
          throw validator.error(ErrorItem.unsatisfiedCondRequirement, { o: name, p: error });
        }
      }
      if ('default' in option) {
        setDefaultValue(validator, values, key, option);
      }
    }
  }
  for (const key of specifiedKeys) {
    const option = validator.options[key];
    if (option.requires) {
      const error = new TerminalString();
      if (!checkRequires(validator, values, specifiedKeys, option.requires, error, false, false)) {
        const name = option.preferredName ?? '';
        throw validator.error(ErrorItem.unsatisfiedRequirement, { o: name, p: error });
      }
    }
  }
}

/**
 * Checks the requirements of an option that was specified.
 * @param validator The option validator
 * @param values The option values
 * @param specifiedKeys The set of specified keys
 * @param requires The option requirements
 * @param error The terminal string error
 * @param negate True if the requirements should be negated
 * @param invert True if the requirements should be inverted
 * @returns True if the requirements were satisfied
 */
function checkRequires(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  specifiedKeys: Set<string>,
  requires: Requires,
  error: TerminalString,
  negate: boolean,
  invert: boolean,
): boolean {
  /** @ignore */
  function checkReqItem(
    requires: Requires,
    error: TerminalString,
    negate: boolean,
    invert: boolean,
  ) {
    return checkRequires(validator, values, specifiedKeys, requires, error, negate, invert);
  }
  /** @ignore */
  function checkKvpItem(
    kvp: [key: string, value: RequiresVal[string]],
    error: TerminalString,
    negate: boolean,
    invert: boolean,
  ) {
    return checkRequirement(validator, values, specifiedKeys, kvp, error, negate, invert);
  }
  if (typeof requires === 'string') {
    return checkRequirement(
      validator,
      values,
      specifiedKeys,
      [requires, undefined],
      error,
      negate,
      invert,
    );
  }
  if (requires instanceof RequiresNot) {
    return checkRequires(validator, values, specifiedKeys, requires.item, error, !negate, invert);
  }
  if (requires instanceof RequiresAll || requires instanceof RequiresOne) {
    const and = requires instanceof RequiresAll !== negate;
    return checkRequireItems(requires.items, checkReqItem, error, negate, invert, and);
  }
  if (typeof requires === 'object') {
    const entries = Object.entries(requires);
    return checkRequireItems(entries, checkKvpItem, error, negate, invert, !negate);
  }
  if (requires(values) == negate) {
    if (negate != invert) {
      error.addWord('not');
    }
    format.v(requires, validator.config.styles, error);
    return false;
  }
  return true;
}

/**
 * Checks if a required option was specified with correct values.
 * @param validator The option validator
 * @param values The option values
 * @param specifiedKeys The set of specified keys
 * @param kvp The required option key and value
 * @param error The terminal string error
 * @param negate True if the requirement should be negated
 * @param invert True if the requirements should be inverted
 * @returns True if the requirement was satisfied
 */
function checkRequirement(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  specifiedKeys: Set<string>,
  kvp: [key: string, value: RequiresVal[string]],
  error: TerminalString,
  negate: boolean,
  invert: boolean,
): boolean {
  const [key, value] = kvp;
  const option = validator.options[key];
  const specified = specifiedKeys.has(key);
  const required = value !== null;
  if (isSpecial(option) || isUnknown(option) || !specified || !required || value === undefined) {
    if ((specified == required) != negate) {
      return true;
    }
    if (specified != invert) {
      error.addWord('no');
    }
    format.o(option.preferredName ?? '', validator.config.styles, error);
    return false;
  }
  return checkRequiredValue(validator, values, option, negate, invert, key, value, error);
}
