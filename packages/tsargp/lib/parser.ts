//--------------------------------------------------------------------------------------------------
// Imports
//--------------------------------------------------------------------------------------------------
import type { HelpSections } from './formatter.js';
import type {
  Options,
  OptionValues,
  OpaqueOption,
  OpaqueOptions,
  OpaqueOptionValues,
  Requires,
  RequiresEntry,
  ResolveCallback,
  DefaultCallback,
  RequiresCallback,
} from './options.js';
import type { Range } from './utils.js';
import type {
  OptionInfo,
  ValidatorConfig,
  ValidationFlags,
  ValidationResult,
} from './validator.js';

import { ConnectiveWord, ErrorItem } from './enums.js';
import { createFormatter, isHelpFormat } from './formatter.js';
import { isOpt, getParamCount, visitRequirements } from './options.js';
import { format, HelpMessage, WarnMessage, TextMessage, TerminalString } from './styles.js';
import {
  areEqual,
  findSimilar,
  getArgs,
  isTrue,
  max,
  findValue,
  getEnv,
  getEntries,
  getKeys,
  mergeValues,
} from './utils.js';
import { OptionValidator, defaultConfig } from './validator.js';

//--------------------------------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------------------------------
/**
 * The default help sections.
 */
const defaultSections: HelpSections = [
  { type: 'usage', title: 'Usage:', indent: 2 },
  { type: 'groups', title: 'Options:' },
];

//--------------------------------------------------------------------------------------------------
// Public types
//--------------------------------------------------------------------------------------------------
/**
 * The parsing flags.
 */
export type ParsingFlags = {
  /**
   * The program name.
   */
  readonly progName?: string;
  /**
   * The completion index of a raw command line.
   */
  readonly compIndex?: number;
  /**
   * The prefix of cluster arguments.
   * If set, then eligible arguments that have this prefix will be considered a cluster.
   */
  readonly clusterPrefix?: string;
};

/**
 * The parsing result.
 */
export type ParsingResult = {
  /**
   * The warnings generated by the parser, if any.
   */
  readonly warning?: WarnMessage;
};

/**
 * The command line or command-line arguments.
 */
export type CommandLine = string | Array<string>;

//--------------------------------------------------------------------------------------------------
// Internal types
//--------------------------------------------------------------------------------------------------
/**
 * Information about the current parsing context.
 */
type ParseContext = [
  validator: OptionValidator,
  values: OpaqueOptionValues,
  args: Array<string>,
  specifiedKeys: Set<string>,
  completing: boolean,
  warning: WarnMessage,
  progName?: string,
  clusterPrefix?: string,
];

/**
 * Information about the current argument sequence.
 */
type ParseEntry = [
  index: number,
  info?: OptionInfo,
  value?: string,
  comp?: boolean,
  marker?: boolean,
  isNew?: boolean,
];

/**
 * A function to check a requirement item.
 * @template T The type of the item
 */
type RequireItemFn<T> = (
  context: ParseContext,
  option: OpaqueOption,
  item: T,
  error: TerminalString,
  negate: boolean,
  invert: boolean,
) => boolean | Promise<boolean>;

//--------------------------------------------------------------------------------------------------
// Classes
//--------------------------------------------------------------------------------------------------
/**
 * Implements parsing of command-line arguments into option values.
 * @template T The type of the option definitions
 */
export class ArgumentParser<T extends Options = Options> {
  private readonly validator: OptionValidator;

  /**
   * Creates an argument parser based on a set of option definitions.
   * @param options The option definitions
   * @param config The validator configuration
   */
  constructor(options: T, config: ValidatorConfig = {}) {
    const concreteConfig = mergeValues(defaultConfig, config);
    this.validator = new OptionValidator(options as OpaqueOptions, concreteConfig);
  }

  /**
   * Validates the option definitions.
   * This should only be called during development and testing, but skipped in production.
   * @param flags The validation flags
   * @returns The validation result
   */
  validate(flags?: ValidationFlags): Promise<ValidationResult> {
    return this.validator.validate(flags);
  }

  /**
   * Parses command-line arguments into option values.
   * @param cmdLine The command line or arguments
   * @param flags The parsing flags
   * @returns The options' values
   */
  async parse(cmdLine?: CommandLine, flags?: ParsingFlags): Promise<OptionValues<T>> {
    const values = {} as OptionValues<T>;
    await this.parseInto(values, cmdLine, flags);
    return values;
  }

  /**
   * Parses command-line arguments into option values.
   * @param values The options' values to parse into
   * @param cmdLine The command line or arguments
   * @param flags The parsing flags
   * @returns The parsing result
   */
  async parseInto(
    values: OptionValues<T>,
    cmdLine = getEnv('COMP_LINE') ?? getEnv('BUFFER') ?? process?.argv.slice(2) ?? [],
    flags?: ParsingFlags,
  ): Promise<ParsingResult> {
    const compIndex =
      flags?.compIndex ??
      (Number(getEnv('COMP_POINT') ?? getEnv('CURSOR')) || getEnv('BUFFER')?.length);
    const args = typeof cmdLine === 'string' ? getArgs(cmdLine, compIndex) : cmdLine;
    const context = createContext(
      this.validator,
      values,
      args,
      !!compIndex,
      flags?.progName,
      flags?.clusterPrefix,
    );
    await parseArgs(context);
    const warning = context[5];
    return warning.length ? { warning } : {};
  }
}

//--------------------------------------------------------------------------------------------------
// Functions
//--------------------------------------------------------------------------------------------------
/**
 * Initializes the command-line arguments for parsing.
 * @param validator The option validator
 * @param values The option values
 * @param args The command-line arguments
 * @param completing True if performing completion
 * @param progName The program name, if any
 * @param clusterPrefix The cluster prefix, if any
 * @returns The parsing context
 */
function createContext(
  validator: OptionValidator,
  values: OpaqueOptionValues,
  args: Array<string>,
  completing: boolean,
  progName = process?.argv[1].split(/[\\/]/).at(-1),
  clusterPrefix?: string,
): ParseContext {
  if (!completing && progName && process?.title) {
    process.title += ' ' + progName;
  }
  for (const [key, option] of getEntries(validator.options)) {
    if (!(key in values) && (!isOpt.msg(option) || option.saveMessage)) {
      values[key] = undefined;
    }
  }
  const specifiedKeys = new Set<string>();
  const warning = new WarnMessage();
  return [validator, values, args, specifiedKeys, completing, warning, progName, clusterPrefix];
}

//--------------------------------------------------------------------------------------------------
// Argument parsing
//--------------------------------------------------------------------------------------------------
/**
 * Parses a cluster argument.
 * @param context The parsing context
 * @param index The argument index
 * @returns True if the argument was a cluster
 */
function parseCluster(context: ParseContext, index: number): boolean {
  /** @ignore */
  function getOpt(letter: string): [string, OpaqueOption, string?] {
    const key = letters.get(letter) ?? '';
    const option = validator.options[key];
    const name = option.names?.find((name): name is string => !!name);
    return [key, option, name];
  }
  const [validator, , args, , completing, , , prefix] = context;
  const cluster = args[index++];
  if (prefix === undefined || !cluster.startsWith(prefix) || cluster.length === prefix.length) {
    return false;
  }
  const letters = validator.letters;
  const rest = cluster.slice(prefix.length);
  const unknownIndex = [...rest].findIndex((letter) => !letters.has(letter));
  if (unknownIndex === 0) {
    return false; // do not consider it a cluster
  }
  if (unknownIndex > 0) {
    const name = getOpt(rest[0])[2];
    args.splice(index, 0, (name ? name + '=' : '') + rest.slice(1));
    return true; // treat it as an inline parameter
  }
  for (let j = 0; j < rest.length && (!completing || index < args.length); ++j) {
    const letter = rest[j];
    const [, option, name] = getOpt(letter);
    const [min, max] = getParamCount(option);
    if (j < rest.length - 1 && (option.type === 'command' || min < max)) {
      throw validator.error(ErrorItem.invalidClusterOption, { o: letter });
    }
    if (name) {
      args.splice(index++, 0, name);
    }
    index += min;
  }
  return true;
}

/**
 * Parses the command-line arguments.
 * @param context The parsing context
 */
async function parseArgs(context: ParseContext) {
  const [validator, values, args, specifiedKeys, completing, warning] = context;
  let prev: ParseEntry = [-1];
  let paramCount: Range = [0, 0];
  let positional = false;
  let checkRequirements = true;
  for (let i = 0, k = 0; i < args.length; i = prev[0]) {
    const next = findNext(context, prev);
    const [j, info, value, comp, marker, isNew] = next;
    if (isNew || !info) {
      if (prev[1]) {
        // process the previous sequence
        const breakLoop = await handleNonNiladic(context, prev[1], i, args.slice(k, j));
        if (breakLoop) {
          checkRequirements = false;
          break; // finished
        }
      }
      if (!info) {
        break; // finished
      }
      prev = next;
      positional = info === validator.positional; // don't use option.positional for this check
      const [key, name, option] = info;
      paramCount = getParamCount(option);
      const [min, max] = paramCount;
      const hasValue = value !== undefined;
      if (marker || (!positional && (max !== 1 || option.inline === false))) {
        if (comp) {
          throw new TextMessage();
        }
        if (hasValue) {
          if (completing) {
            // ignore disallowed inline parameters while completing
            prev[1] = undefined;
            prev[4] = false;
            continue;
          }
          const [alt, name2] = marker ? [1, info[3]] : [0, name];
          throw validator.error(ErrorItem.disallowedInlineParameter, { o: name2 }, { alt });
        }
      } else if (min && !hasValue && option.inline === 'always') {
        if (completing) {
          // ignore required inline parameters while completing
          prev[1] = undefined;
          continue;
        }
        throw validator.error(ErrorItem.missingInlineParameter, { o: name });
      }
      if (!completing && !specifiedKeys.has(key)) {
        if (option.deprecated) {
          warning.push(validator.format(ErrorItem.deprecatedOption, { o: name }));
        }
        specifiedKeys.add(key);
      }
      if (!max) {
        // comp === false
        const [breakLoop, skipCount] = await handleNiladic(context, info, j, args.slice(j + 1));
        if (breakLoop) {
          checkRequirements = false;
          break; // finished
        }
        prev[0] += skipCount;
        prev[1] = undefined;
        continue; // fetch more
      }
      if (!comp) {
        if (positional || !hasValue) {
          // positional marker, first positional parameter or option name
          k = hasValue ? j : j + 1;
        } else {
          // option name with inline parameter
          const breakLoop = await handleNonNiladic(context, info, j, [value]);
          if (breakLoop) {
            checkRequirements = false;
            break; // finished
          }
          prev[1] = undefined;
        }
        continue; // fetch more
      }
      // perform completion of first positional or inline parameter
      k = j;
    }
    if (!info) {
      break; // finished
    }
    // comp === true
    const words = await completeParameter(values, info, i, args.slice(k, j), value);
    if (!marker && ((j === k && positional) || j - k >= paramCount[0])) {
      words.push(...completeName(validator, value));
    }
    throw new TextMessage(...words);
  }
  if (checkRequirements) {
    await checkRequired(context);
  }
}

/**
 * Finds the start of the next sequence in the command-line arguments, or a word to complete.
 * If a sequence is found, it is a new option specification (but the option can be the same).
 * @param context The parsing context
 * @param prev The previous parse entry
 * @returns The new parse entry
 */
function findNext(context: ParseContext, prev: ParseEntry): ParseEntry {
  const [validator, , args, , completing] = context;
  const [index, info, prevVal, , marker] = prev;
  const inc = prevVal !== undefined ? 1 : 0;
  const positional = validator.positional;
  const [min, max] = info ? getParamCount(info[2]) : [0, 0];
  for (let i = index + 1; i < args.length; ++i) {
    const arg = args[i];
    const comp = completing && i + 1 === args.length;
    if (!info || (!marker && i - index + inc > min)) {
      const [name, value] = arg.split(/=(.*)/, 2);
      const key = validator.names.get(name);
      if (key) {
        if (comp && value === undefined) {
          throw new TextMessage(name);
        }
        const marker = name === positional?.[3];
        const info = marker ? positional : ([key, name, validator.options[key]] as OptionInfo);
        return [i, info, value, comp, marker, true];
      }
      if (parseCluster(context, i)) {
        if (comp) {
          throw new TextMessage();
        }
        continue;
      }
      if (!info || i - index + inc > max) {
        if (!positional) {
          if (comp) {
            throw new TextMessage(...completeName(validator, arg));
          }
          if (completing) {
            continue; // ignore unknown options during completion
          }
          reportUnknownName(validator, name);
        }
        return [i, positional, arg, comp, false, true];
      }
    }
    if (comp) {
      return [i, info, arg, comp, marker, false];
    }
  }
  return [args.length];
}

/**
 * Reports an error of unknown option name.
 * @param validator The option validator
 * @param name The unknown option name
 */
function reportUnknownName(validator: OptionValidator, name: string): never {
  const similar = findSimilar(name, validator.names.keys(), 0.6);
  const [args, alt] = similar.length ? [{ o1: name, o2: similar }, 1] : [{ o: name }, 0];
  const sep = validator.config.connectives[ConnectiveWord.optionSep];
  throw validator.error(ErrorItem.unknownOption, args, { alt, sep });
}

/**
 * Completes an option name.
 * @param validator The option validator
 * @param prefix The name prefix, if any
 * @returns The completion words
 */
function completeName(validator: OptionValidator, prefix?: string): Array<string> {
  const names = [...validator.names.keys()];
  return prefix ? names.filter((name) => name.startsWith(prefix)) : names;
}

/**
 * Completes an option parameter.
 * @param values The option values
 * @param info The option information
 * @param index The starting index of the argument sequence
 * @param param The preceding parameters, if any
 * @param comp The word being completed
 * @returns The completion words
 */
async function completeParameter(
  values: OpaqueOptionValues,
  info: OptionInfo,
  index: number,
  param: Array<string>,
  comp = '',
): Promise<Array<string>> {
  const [, name, option] = info;
  let words: Array<string>;
  if (option.complete) {
    try {
      // do not destructure `complete`, because the callback might need to use `this`
      words = await option.complete({ values, index, name, param, comp });
    } catch (err) {
      // do not propagate errors during completion
      words = [];
    }
  } else {
    words = isOpt.bool(option)
      ? [...(option.truthNames ?? []), ...(option.falsityNames ?? [])]
      : option.enums?.map((val) => `${val}`) ?? [];
    if (comp) {
      words = words.filter((word) => word.startsWith(comp));
    }
  }
  return words;
}

//--------------------------------------------------------------------------------------------------
// Value handling
//--------------------------------------------------------------------------------------------------
/**
 * Parses the value(s) of the option parameter(s).
 * @param context The parsing context
 * @param info The option information
 * @param index The starting index of the argument sequence
 * @param params The option parameter(s)
 * @returns A promise that must be awaited before continuing
 */
async function parseParam(
  context: ParseContext,
  info: OptionInfo,
  index: number,
  params: Array<string>,
) {
  /** @ignore */
  function norm<T>(val: T) {
    return validator.normalize(option, name, val);
  }
  /** @ignore */
  function bool(str: string): boolean {
    const result = isTrue(str, option);
    if (result === undefined) {
      const names = [...(option.truthNames ?? []), ...(option.falsityNames ?? [])];
      const args = { o: name, s1: str, s2: names };
      const sep = validator.config.connectives[ConnectiveWord.stringSep];
      throw validator.error(ErrorItem.enumsConstraintViolation, args, { alt: 0, sep });
    }
    return result;
  }
  const [key, name, option] = info;
  if (!params.length) {
    return setValue(context, key, option, 'fallback');
  }
  const [validator, values, , , comp] = context;
  const convertFn: (val: string) => unknown = isOpt.bool(option)
    ? bool
    : isOpt.str(option)
      ? (str: string) => str
      : Number;
  const lastParam = params[params.length - 1];
  let value;
  if (isOpt.arr(option)) {
    const separator = option.separator;
    const param = separator ? lastParam.split(separator) : params;
    // do not destructure `parse`, because the callback might need to use `this`
    if (option.parse) {
      const seq = { values, index, name, param, comp };
      value = ((await option.parse(seq)) as Array<unknown>).map(norm);
    } else {
      value = option.append ? (values[key] as Array<unknown>) ?? [] : [];
      value.push(...param.map(convertFn).map(norm));
    }
  } else {
    const seq = { values, index, name, param: lastParam, comp };
    value = option.parse ? await option.parse(seq) : convertFn(lastParam);
  }
  values[key] = norm(value);
}

/**
 * Sets the normalized value of an option.
 * @param context The parsing context
 * @param key The option key
 * @param option The option definition
 * @param prop The option property whose value is to be set
 */
async function setValue(
  context: ParseContext,
  key: string,
  option: OpaqueOption,
  prop: 'default' | 'fallback',
) {
  /** @ignore */
  function norm<T>(val: T) {
    return validator.normalize(option, key, val);
  }
  const [validator, values] = context;
  if (option[prop] === undefined) {
    values[key] = undefined;
    return;
  }
  // do not destructure `prop`, because the callback might need to use `this`
  const resolved =
    typeof option[prop] === 'function'
      ? await (option[prop] as DefaultCallback<unknown>)(values)
      : option[prop];
  values[key] =
    isOpt.ukn(option) || isOpt.bool(option)
      ? resolved
      : isOpt.arr(option)
        ? norm((resolved as Array<unknown>).map(norm))
        : norm(resolved);
}

//--------------------------------------------------------------------------------------------------
// Option handling
//--------------------------------------------------------------------------------------------------
/**
 * Handles a non-niladic option.
 * @param context The parsing context
 * @param info The option information
 * @param index The starting index of the argument sequence
 * @param params The option parameters, if any
 * @returns True if the parsing loop should be broken
 */
async function handleNonNiladic(
  context: ParseContext,
  info: OptionInfo,
  index: number,
  params: Array<string>,
): Promise<boolean> {
  const [, name, option] = info;
  // max is not needed here because either:
  // - the parser would have failed to find an option that starts a new sequence at max + 1; or
  // - it would have reached the end of the arguments before max + 1
  if (params.length < getParamCount(option)[0]) {
    throw context[0].error(ErrorItem.missingParameter, { o: name });
  }
  if (option.type === 'function') {
    // since we know this is a function option, we're deliberately reusing the niladic handling,
    // with params as the "rest", and ignoring the skip count
    const [breakLoop] = await handleNiladic(context, info, index, params);
    return breakLoop;
  }
  try {
    // use await here instead of return, in order to catch errors
    await parseParam(context, info, index, params);
  } catch (err) {
    // do not propagate errors during completion
    if (!context[4]) {
      throw err;
    }
  }
  return false;
}

/**
 * Handles a niladic option.
 * @param context The parsing context
 * @param info The option information
 * @param index The starting index of the argument sequence
 * @param rest The remaining command-line arguments
 * @returns [True if the parsing loop should be broken, number of additional processed arguments]
 */
async function handleNiladic(
  context: ParseContext,
  info: OptionInfo,
  index: number,
  rest: Array<string>,
): Promise<[boolean, number]> {
  const [, values, , , comp] = context;
  const [key, name, option] = info;
  switch (option.type) {
    case 'flag': {
      values[key] = !option.negationNames?.includes(name);
      return [false, 0];
    }
    case 'function': {
      const breakLoop = !!option.break && !comp;
      if (breakLoop) {
        await checkRequired(context);
      }
      const skipCount = await handleFunction(context, info, index, rest);
      return [breakLoop, skipCount];
    }
    case 'command': {
      if (!comp) {
        await checkRequired(context);
      }
      await handleCommand(context, info, index, rest);
      return [true, 0];
    }
    default: {
      // skip message-valued options during completion
      if (!comp) {
        await handleMessage(context, info, rest);
      }
      return [!comp, 0];
    }
  }
}

/**
 * Handles a function option.
 * @param context The parsing context
 * @param info The option information
 * @param index The starting index of the argument sequence
 * @param param The remaining command-line arguments
 * @returns The number of additional processed arguments
 */
async function handleFunction(
  context: ParseContext,
  info: OptionInfo,
  index: number,
  param: Array<string>,
): Promise<number> {
  const [key, name, option] = info;
  if (option.exec) {
    const [, values, , , comp] = context;
    try {
      // do not destructure `exec`, because the callback might need to use `this`
      values[key] = await option.exec({ values, index, name, param, comp });
    } catch (err) {
      // do not propagate common errors during completion
      if (!comp || err instanceof TextMessage) {
        throw err;
      }
    }
  }
  return max(0, option.skipCount ?? 0);
}

/**
 * Handles a command option.
 * @param context The parsing context
 * @param info The option information
 * @param index The starting index of the argument sequence
 * @param rest The remaining command-line arguments
 * @returns The result of parsing the command arguments
 */
async function handleCommand(
  context: ParseContext,
  info: OptionInfo,
  index: number,
  rest: Array<string>,
) {
  const [validator, values, , , comp, warning] = context;
  const [key, name, option] = info;
  // do not destructure `options`, because the callback might need to use `this`
  const cmdOptions =
    typeof option.options === 'function' ? await option.options() : option.options ?? {};
  const cmdValidator = new OptionValidator(cmdOptions as OpaqueOptions, validator.config);
  const param: OpaqueOptionValues = {};
  const cmdContext = createContext(cmdValidator, param, rest, comp, name, option.clusterPrefix);
  await parseArgs(cmdContext);
  warning.push(...cmdContext[5]);
  // comp === false, otherwise completion will have taken place by now
  if (option.exec) {
    // do not destructure `exec`, because the callback might need to use `this`
    values[key] = await option.exec({ values, index, name, param });
  }
}

/**
 * Handles a message-valued option.
 * @param context The parsing context
 * @param info The option information
 * @param rest The remaining command-line arguments
 * @throws The help or version message
 */
async function handleMessage(context: ParseContext, info: OptionInfo, rest: Array<string>) {
  const [validator, values] = context;
  const [key, , option] = info;
  const message =
    option.type === 'help'
      ? await handleHelp(context, option, rest)
      : option.resolve
        ? await handleVersion(validator, option.resolve)
        : option.version ?? '';
  if (option.saveMessage) {
    values[key] = message;
  } else {
    throw message;
  }
}

/**
 * Handles a help option.
 * @param context The parsing context
 * @param option The option definition
 * @param rest The remaining command-line arguments
 * @returns The help message
 */
async function handleHelp(
  context: ParseContext,
  option: OpaqueOption,
  rest: Array<string>,
): Promise<HelpMessage> {
  let [validator, , , , , , progName] = context;
  if (option.useNested && rest.length) {
    const cmdOpt = findValue(
      validator.options,
      (opt) => opt.type === 'command' && !!opt.names?.includes(rest[0]),
    );
    if (cmdOpt) {
      if (cmdOpt.options) {
        // do not destructure `options`, because the callback might need to use `this`
        const resolved = (
          typeof cmdOpt.options === 'function' ? await cmdOpt.options() : cmdOpt.options
        ) as OpaqueOptions;
        const helpOpt = findValue(resolved, (opt) => opt.type === 'help');
        if (helpOpt) {
          validator = new OptionValidator(resolved, validator.config);
          option = helpOpt;
          rest.splice(0, 1); // only if the command has help; otherwise, it may be an option filter
        }
      }
    }
  }
  let format;
  if (option.useFormat && rest.length && isHelpFormat(rest[0])) {
    format = rest[0];
    rest.splice(0, 1); // only if the format is recognized; otherwise, it may be an option filter
  }
  const config = option.config ?? {};
  if (option.useFilter) {
    config.filter = rest;
  }
  const formatter = createFormatter(validator, config, format);
  const sections = option.sections ?? defaultSections;
  return formatter.sections(sections, progName);
}

/**
 * Resolve a package version using a module-resolve function.
 * @param validator The option validator
 * @param resolve The resolve callback
 * @returns The version string
 */
async function handleVersion(
  validator: OptionValidator,
  resolve: ResolveCallback,
): Promise<string> {
  const { promises } = await import('fs');
  for (
    let path = './package.json', resolved = resolve(path), lastResolved;
    resolved !== lastResolved;
    lastResolved = resolved, path = '../' + path, resolved = resolve(path)
  ) {
    try {
      const data = await promises.readFile(new URL(resolved));
      return JSON.parse(data.toString()).version;
    } catch (err) {
      if ((err as ErrnoException).code !== 'ENOENT') {
        throw err;
      }
    }
  }
  throw validator.error(ErrorItem.missingPackageJson);
}

//--------------------------------------------------------------------------------------------------
// Requirements handling
//--------------------------------------------------------------------------------------------------
/**
 * Checks if required options were correctly specified.
 * This should only be called when completion is not in effect.
 * @param context The parsing context
 */
async function checkRequired(context: ParseContext) {
  const keys = getKeys(context[0].options);
  // we may need to serialize the following call
  await Promise.all(keys.map((key) => checkEnvVarAndDefaultValue(context, key)));
  await Promise.all(keys.map((key) => checkRequiredOption(context, key)));
}

/**
 * Checks if there is an environment variable or default value for an option.
 * @param context The parsing context
 * @param key The option key
 * @returns A promise that must be awaited before continuing
 */
async function checkEnvVarAndDefaultValue(context: ParseContext, key: string) {
  const [validator, , , specifiedKeys] = context;
  if (specifiedKeys.has(key)) {
    return;
  }
  const option = validator.options[key];
  const envVar = option.envVar;
  if (envVar) {
    const value = getEnv(envVar);
    if (value !== undefined) {
      if (option.type === 'flag') {
        // don't parse the flag value, for consistency with the semantics of the command-line
        context[1][key] = true;
      } else {
        const handleFn = option.type === 'function' ? handleFunction : parseParam;
        await handleFn(context, [key, envVar, option], NaN, [value]);
      }
      specifiedKeys.add(key);
      return;
    }
  }
  if (option.required) {
    const name = option.preferredName ?? '';
    throw validator.error(ErrorItem.missingRequiredOption, { o: name });
  }
  if ('default' in option) {
    return setValue(context, key, option, 'default'); // sets undefined as well
  }
}

/**
 * Checks the requirements of an option.
 * @param context The parsing context
 * @param key The option key
 */
async function checkRequiredOption(context: ParseContext, key: string) {
  /** @ignore */
  function check(requires: Requires, negate: boolean, invert: boolean) {
    return checkRequires(context, option, requires, error, negate, invert);
  }
  const [validator, , , specifiedKeys] = context;
  const option = validator.options[key];
  const specified = specifiedKeys.has(key);
  const requires = option.requires;
  const requiredIf = option.requiredIf;
  const error = new TerminalString();
  if (
    (specified && requires && !(await check(requires, false, false))) ||
    (!specified && requiredIf && !(await check(requiredIf, true, true)))
  ) {
    const name = option.preferredName ?? '';
    const kind = specified
      ? ErrorItem.unsatisfiedRequirement
      : ErrorItem.unsatisfiedCondRequirement;
    throw validator.error(kind, { o: name, p: error });
  }
}

/**
 * Checks the requirements of an option that was specified.
 * @param context The parsing context
 * @param option The option definition
 * @param requires The option requirements
 * @param error The terminal string error
 * @param negate True if the requirements should be negated
 * @param invert True if the requirements should be inverted
 * @returns True if the requirements were satisfied
 */
async function checkRequires(
  context: ParseContext,
  option: OpaqueOption,
  requires: Requires,
  error: TerminalString,
  negate: boolean,
  invert: boolean,
): Promise<boolean> {
  /** @ignore */
  function checkItems<T>(items: Array<T>, checkFn: RequireItemFn<T>, and: boolean) {
    return checkRequireItems(context, option, items, checkFn, error, negate, invert, and);
  }
  return visitRequirements(
    requires,
    (req) =>
      Promise.resolve(checkRequiresEntry(context, option, [req, undefined], error, negate, invert)),
    (req) => checkRequires(context, option, req.item, error, !negate, invert),
    (req) => checkItems(req.items, checkRequires, !negate),
    (req) => checkItems(req.items, checkRequires, negate),
    (req) => checkItems(getEntries(req), checkRequiresEntry, !negate),
    (req) => checkRequiresCallback(context, option, req, error, negate, invert),
  );
}

/**
 * Checks if a required option was specified with correct values.
 * @param context The parsing context
 * @param _option The requiring option definition
 * @param entry The required option key and value
 * @param error The terminal string error
 * @param negate True if the requirement should be negated
 * @param invert True if the requirements should be inverted
 * @returns True if the requirement was satisfied
 */
function checkRequiresEntry(
  context: ParseContext,
  _option: OpaqueOption,
  entry: RequiresEntry,
  error: TerminalString,
  negate: boolean,
  invert: boolean,
): boolean {
  /** @ignore */
  function norm<T>(val: T) {
    return validator.normalize(option, name, val);
  }
  const [validator, values, , specifiedKeys] = context;
  const [key, value] = entry;
  const actual = values[key];
  const option = validator.options[key];
  const specified = specifiedKeys.has(key) || actual !== undefined; // consider default values
  const required = value !== null;
  if (isOpt.msg(option) || isOpt.ukn(option) || !specified || !required || value === undefined) {
    if ((specified === required) !== negate) {
      return true;
    }
    const { styles, connectives } = validator.config;
    if (specified !== invert) {
      error.word(connectives[ConnectiveWord.no]);
    }
    format.o(option.preferredName ?? '', styles, error);
    return false;
  }
  const spec = isOpt.bool(option) ? 'b' : isOpt.str(option) ? 's' : 'n';
  const name = option.preferredName ?? '';
  const array = Array.isArray(value);
  let expected;
  if (array) {
    expected = norm(value.map(norm));
    if (areEqual(actual as ReadonlyArray<unknown>, expected, option.unique) !== negate) {
      return true;
    }
  } else {
    expected = norm(value);
    if ((actual === expected) !== negate) {
      return true;
    }
  }
  const { styles, connectives } = validator.config;
  const connective =
    negate !== invert ? connectives[ConnectiveWord.notEquals] : connectives[ConnectiveWord.equals];
  const phrase = array ? `[%${spec}]` : `%${spec}`;
  format.o(name, styles, error);
  error.word(connective).format(styles, phrase, { [spec]: expected });
  return false;
}

/**
 * Checks the items of a requirement expression or object.
 * @param context The parsing context
 * @param option The option definition
 * @param items The list of requirement items
 * @param itemFn The callback to execute on each item
 * @param error The terminal string error
 * @param negate True if the requirement should be negated
 * @param invert True if the requirements should be inverted
 * @param and If true, return on the first error; else return on the first success
 * @returns True if the requirement was satisfied
 */
async function checkRequireItems<T>(
  context: ParseContext,
  option: OpaqueOption,
  items: Array<T>,
  itemFn: RequireItemFn<T>,
  error: TerminalString,
  negate: boolean,
  invert: boolean,
  and: boolean,
): Promise<boolean> {
  const connectives = context[0].config.connectives;
  const connective = invert ? connectives[ConnectiveWord.and] : connectives[ConnectiveWord.or];
  if (!and && items.length > 1) {
    error.open('(');
  }
  let first = true;
  for (const item of items) {
    if (and || first) {
      first = false;
    } else {
      error.word(connective);
    }
    const success = await itemFn(context, option, item, error, negate, invert);
    if (success !== and) {
      return success;
    }
  }
  if (and) {
    return true;
  }
  if (items.length > 1) {
    error.close(')');
  }
  return false;
}

/**
 * Checks the result of a requirement callback.
 * @param context The parsing context
 * @param option The option definition
 * @param callback The requirement callback
 * @param error The terminal string error
 * @param negate True if the requirements should be negated
 * @param invert True if the requirements should be inverted
 * @returns True if the requirements were satisfied
 */
async function checkRequiresCallback(
  context: ParseContext,
  option: OpaqueOption,
  callback: RequiresCallback,
  error: TerminalString,
  negate: boolean,
  invert: boolean,
): Promise<boolean> {
  const [validator, values] = context;
  const result = await callback.bind(option)(values);
  if (result === negate) {
    const { styles, connectives } = validator.config;
    if (negate !== invert) {
      error.word(connectives[ConnectiveWord.not]);
    }
    format.v(callback, styles, error);
    return false;
  }
  return true;
}
